# Story 2.7: Chat Provider and State Management

## Status
Draft

## Story
**As a** frontend developer,
**I want** a React Context provider managing chat state with message history and processing status,
**so that** chat components can access and update conversation state in a centralized, type-safe manner.

## Acceptance Criteria
1. ChatProvider component created with React Context and useReducer
2. Chat state includes: messages array, isProcessing boolean, sessionId string, error object
3. Provider exposes sendMessage function that calls chat API
4. Provider exposes clearMessages function to reset conversation
5. Session ID persists in localStorage across page refreshes
6. Messages persist in memory during session (lost on page refresh - OK for MVP)
7. Provider handles loading states during API calls
8. Provider catches and stores API errors in state
9. Custom useChatContext hook for type-safe context access
10. Unit tests verify state updates and API integration

## Tasks / Subtasks

- [ ] Define chat state types in `components/providers/chat-provider.tsx` (AC: 2)
  - [ ] Define ChatState interface with: messages, isProcessing, sessionId, error
  - [ ] Define ChatAction union type for reducer actions
  - [ ] Define ChatContextValue interface with state + methods
  - [ ] Import Message type from lib/types or define locally

- [ ] Create chat reducer function (AC: 2, 7, 8)
  - [ ] Implement ADD_MESSAGE action (appends message to array)
  - [ ] Implement SET_PROCESSING action (updates isProcessing boolean)
  - [ ] Implement SET_ERROR action (stores error object)
  - [ ] Implement SET_SESSION_ID action (updates sessionId)
  - [ ] Implement CLEAR_MESSAGES action (resets messages array)
  - [ ] Use switch statement for type-safe action handling

- [ ] Create ChatProvider component (AC: 1, 5, 6)
  - [ ] Add 'use client' directive
  - [ ] Define props interface: children, initialSessionId?
  - [ ] Create React Context: `const ChatContext = createContext<ChatContextValue | null>(null)`
  - [ ] Use useReducer with chatReducer and initialState
  - [ ] Initialize sessionId from localStorage or generate new UUID
  - [ ] useEffect to persist sessionId to localStorage on change
  - [ ] Wrap children with ChatContext.Provider

- [ ] Implement sendMessage function (AC: 3, 7, 8)
  - [ ] Import sendMessage from lib/api/chat
  - [ ] Dispatch SET_PROCESSING(true) before API call
  - [ ] Try-catch block for API call
  - [ ] On success: dispatch ADD_MESSAGE with response data
  - [ ] On error: dispatch SET_ERROR with error object
  - [ ] Finally: dispatch SET_PROCESSING(false)
  - [ ] Return success/error status for optimistic updates (Story 2.8)

- [ ] Implement clearMessages function (AC: 4)
  - [ ] Dispatch CLEAR_MESSAGES action
  - [ ] Optionally reset sessionId (generate new UUID)
  - [ ] Clear any existing errors

- [ ] Create custom hook for context access (AC: 9)
  - [ ] Export `useChatContext()` hook
  - [ ] Call useContext(ChatContext)
  - [ ] Throw error if context is null (used outside provider)
  - [ ] Return typed ChatContextValue

- [ ] Add localStorage session persistence (AC: 5)
  - [ ] Key: 'orchestratai_session_id'
  - [ ] On mount: read from localStorage or generate new UUID
  - [ ] useEffect: save sessionId to localStorage when it changes
  - [ ] Handle localStorage errors gracefully (private browsing)

- [ ] Add error recovery utilities (AC: 8)
  - [ ] Implement clearError() method to reset error state
  - [ ] Auto-clear error after successful message send
  - [ ] Include error details in context value

- [ ] Write unit tests for provider (AC: 10)
  - [ ] Test initial state has empty messages array
  - [ ] Test sendMessage dispatches ADD_MESSAGE on success
  - [ ] Test sendMessage dispatches SET_ERROR on API failure
  - [ ] Test isProcessing toggles correctly during API call
  - [ ] Test clearMessages resets state
  - [ ] Test sessionId persists to localStorage
  - [ ] Test sessionId loads from localStorage on mount
  - [ ] Test useChatContext throws error when used outside provider
  - [ ] Mock sendMessage API call with vi.mock

## Dev Notes

### Previous Story Context
- Story 2.4 created `sendMessage(message, sessionId)` API function
- Story 2.5 created message display components (MessageBubble, MessageList)
- Story 2.6 created InputArea component with onSendMessage callback
- Story 2.8 will add optimistic updates using this provider

### State Management Pattern
[Source: docs/architecture/9-frontend-architecture.md#92-state-management]

**React Context + useReducer Pattern:**
```typescript
'use client';

const ChatContext = createContext<ChatContextValue | null>(null);

export function ChatProvider({ children, initialSessionId }: Props) {
  const [state, dispatch] = useReducer(chatReducer, initialState);

  const sendMessage = async (text: string) => {
    dispatch({ type: 'SET_PROCESSING', payload: true });

    const result = await sendMessageSafe(text, state.sessionId);

    if (result.success) {
      dispatch({ type: 'ADD_MESSAGE', payload: result.data });
    }

    dispatch({ type: 'SET_PROCESSING', payload: false });
  };

  return (
    <ChatContext.Provider value={{ state, sendMessage }}>
      {children}
    </ChatContext.Provider>
  );
}
```

### Component Architecture
[Source: docs/architecture/6-components.md#61-frontend-components]

**ChatProvider Responsibilities:**
- Global state management for chat
- React Context + useReducer
- Dependencies: APIClient, localStorage

**State Shape:**
```typescript
interface ChatState {
  messages: Message[];
  isProcessing: boolean;
  sessionId: string | null;
  error: Error | null;
}

interface ChatContextValue {
  messages: Message[];
  isProcessing: boolean;
  sessionId: string | null;
  error: Error | null;
  sendMessage: (message: string) => Promise<void>;
  clearMessages: () => void;
  clearError: () => void;
}
```

### File Locations
[Source: docs/architecture/9-frontend-architecture.md#91-component-organization]

**Create this file:**
```
orchestratai_client/src/components/providers/
└── chat-provider.tsx        # React Context provider
```

**Test file:**
```
orchestratai_client/src/components/providers/__tests__/
└── chat-provider.test.tsx
```

### Implementation Pattern

```tsx
'use client';

import { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';
import { sendMessage as sendMessageAPI } from '@/lib/api/chat';
import type { ChatResponse } from '@/lib/schemas';

// Types
interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  agent?: string;
  confidence?: number;
  timestamp: Date;
}

interface ChatState {
  messages: Message[];
  isProcessing: boolean;
  sessionId: string | null;
  error: Error | null;
}

type ChatAction =
  | { type: 'ADD_MESSAGE'; payload: Message }
  | { type: 'SET_PROCESSING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: Error | null }
  | { type: 'SET_SESSION_ID'; payload: string }
  | { type: 'CLEAR_MESSAGES' };

interface ChatContextValue extends ChatState {
  sendMessage: (message: string) => Promise<void>;
  clearMessages: () => void;
  clearError: () => void;
}

// Reducer
function chatReducer(state: ChatState, action: ChatAction): ChatState {
  switch (action.type) {
    case 'ADD_MESSAGE':
      return { ...state, messages: [...state.messages, action.payload], error: null };
    case 'SET_PROCESSING':
      return { ...state, isProcessing: action.payload };
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    case 'SET_SESSION_ID':
      return { ...state, sessionId: action.payload };
    case 'CLEAR_MESSAGES':
      return { ...state, messages: [], error: null };
    default:
      return state;
  }
}

// Context
const ChatContext = createContext<ChatContextValue | null>(null);

// Provider
const SESSION_ID_KEY = 'orchestratai_session_id';

export function ChatProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(chatReducer, {
    messages: [],
    isProcessing: false,
    sessionId: null,
    error: null,
  });

  // Initialize sessionId from localStorage
  useEffect(() => {
    try {
      const stored = localStorage.getItem(SESSION_ID_KEY);
      const sessionId = stored || crypto.randomUUID();
      dispatch({ type: 'SET_SESSION_ID', payload: sessionId });
      if (!stored) {
        localStorage.setItem(SESSION_ID_KEY, sessionId);
      }
    } catch {
      // Fallback if localStorage unavailable
      dispatch({ type: 'SET_SESSION_ID', payload: crypto.randomUUID() });
    }
  }, []);

  // Persist sessionId to localStorage
  useEffect(() => {
    if (state.sessionId) {
      try {
        localStorage.setItem(SESSION_ID_KEY, state.sessionId);
      } catch {
        // Ignore localStorage errors
      }
    }
  }, [state.sessionId]);

  const sendMessage = async (message: string) => {
    dispatch({ type: 'SET_PROCESSING', payload: true });

    try {
      const response = await sendMessageAPI(message, state.sessionId!);

      // Add user message
      dispatch({
        type: 'ADD_MESSAGE',
        payload: {
          id: crypto.randomUUID(),
          role: 'user',
          content: message,
          timestamp: new Date(),
        },
      });

      // Add AI response
      dispatch({
        type: 'ADD_MESSAGE',
        payload: {
          id: crypto.randomUUID(),
          role: 'assistant',
          content: response.message,
          agent: response.agent,
          confidence: response.confidence,
          timestamp: new Date(),
        },
      });
    } catch (error) {
      dispatch({ type: 'SET_ERROR', payload: error as Error });
    } finally {
      dispatch({ type: 'SET_PROCESSING', payload: false });
    }
  };

  const clearMessages = () => {
    dispatch({ type: 'CLEAR_MESSAGES' });
  };

  const clearError = () => {
    dispatch({ type: 'SET_ERROR', payload: null });
  };

  const value: ChatContextValue = {
    ...state,
    sendMessage,
    clearMessages,
    clearError,
  };

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
}

// Custom hook
export function useChatContext() {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChatContext must be used within ChatProvider');
  }
  return context;
}
```

### localStorage Key Convention
Use prefixed keys to avoid collisions: `orchestratai_session_id`

### Error Handling
- Store errors in state for UI display
- Auto-clear errors on successful operations
- Gracefully handle localStorage unavailability (Safari private mode)

### Technical Constraints
[Source: docs/architecture/3-tech-stack.md]

- React: 19.2 (React Context, useReducer)
- State Management: React Context + useReducer (Phase 1-2), TanStack Query later
- No external state libraries for MVP

### Coding Standards
[Source: docs/architecture/16-coding-standards.md]

- **Client Components:** Add 'use client' directive for context providers
- **Type Safety:** Fully typed reducer actions and state
- **Naming:** PascalCase for provider, camelCase for hook

### Testing

[Source: docs/architecture/15-testing-strategy.md]

**Test Framework:** Vitest with @testing-library/react
**Test Location:** `orchestratai_client/src/components/providers/__tests__/chat-provider.test.tsx`
**Test Type:** Unit tests

**Test Pattern:**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';
import { ChatProvider, useChatContext } from '../chat-provider';
import * as chatAPI from '@/lib/api/chat';

vi.mock('@/lib/api/chat');

describe('ChatProvider', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  it('initializes with empty messages', () => {
    const { result } = renderHook(() => useChatContext(), {
      wrapper: ChatProvider,
    });

    expect(result.current.messages).toEqual([]);
    expect(result.current.isProcessing).toBe(false);
  });

  it('sends message and adds to state', async () => {
    const mockResponse = {
      message: 'Response',
      agent: 'orchestrator',
      confidence: 0.9,
      logs: [],
      metrics: { tokensUsed: 100, cost: 0.001, latency: 500 },
    };

    vi.mocked(chatAPI.sendMessage).mockResolvedValue(mockResponse);

    const { result } = renderHook(() => useChatContext(), {
      wrapper: ChatProvider,
    });

    await act(async () => {
      await result.current.sendMessage('Hello');
    });

    await waitFor(() => {
      expect(result.current.messages).toHaveLength(2); // User + AI
      expect(result.current.messages[0].content).toBe('Hello');
      expect(result.current.messages[1].content).toBe('Response');
    });
  });

  it('persists sessionId to localStorage', async () => {
    const { result } = renderHook(() => useChatContext(), {
      wrapper: ChatProvider,
    });

    await waitFor(() => {
      expect(result.current.sessionId).toBeTruthy();
      expect(localStorage.getItem('orchestratai_session_id')).toBe(result.current.sessionId);
    });
  });

  it('throws error when used outside provider', () => {
    expect(() => {
      renderHook(() => useChatContext());
    }).toThrow('useChatContext must be used within ChatProvider');
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
<!-- Populated by dev agent -->

### Debug Log References
<!-- Populated by dev agent -->

### Completion Notes List
<!-- Populated by dev agent -->

### File List
<!-- Populated by dev agent -->

## QA Results
<!-- Populated by QA agent -->
