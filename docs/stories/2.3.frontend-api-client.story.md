# Story 2.3: Frontend API Client with Error Handling

## Status
Done

## Story
**As a** frontend developer,
**I want** a type-safe API client with comprehensive error handling and retry logic,
**so that** all HTTP requests to the backend are validated, errors are properly classified, and the application handles network failures gracefully.

## Acceptance Criteria
1. Base API client class created in `lib/api-client.ts` with generic request method
2. Custom error classes created: `APIError`, `ValidationError`, `NetworkError`, `TimeoutError`
3. All API responses validated against expected types (using TypeScript generics)
4. Request timeout implemented (30 seconds default, configurable)
5. Automatic retry logic for network errors (max 3 attempts with exponential backoff)
6. Environment variable `NEXT_PUBLIC_API_URL` used for base URL configuration
7. Request/response logging in development mode only
8. Error responses include status code, message, and optional details

## Tasks / Subtasks

- [x] Create custom error classes in `orchestratai_client/src/lib/errors.ts` (AC: 2, 8)
  - [x] Define base `APIError` class with statusCode, message, details properties
  - [x] Define `ValidationError` extending APIError for schema validation failures
  - [x] Define `NetworkError` extending APIError for fetch failures
  - [x] Define `TimeoutError` extending APIError for request timeouts
  - [x] Add proper error name assignment in constructors
  - [x] Add type definitions for error details

- [x] Create base API client in `orchestratai_client/src/lib/api-client.ts` (AC: 1, 3, 4, 6, 7)
  - [x] Define `APIClient` class with baseUrl property
  - [x] Read baseUrl from `process.env.NEXT_PUBLIC_API_URL` or default to 'http://localhost:8000'
  - [x] Implement generic `request<T>()` method with timeout support
  - [x] Use AbortController for 30-second timeout
  - [x] Parse and type-check response JSON
  - [x] Throw `APIError` for non-2xx status codes
  - [x] Add development-only console logging (check process.env.NODE_ENV)

- [x] Implement HTTP method helpers (AC: 1)
  - [x] Implement `get<T>(endpoint: string)` method
  - [x] Implement `post<T>(endpoint: string, data: unknown)` method
  - [x] Implement `put<T>(endpoint: string, data: unknown)` method
  - [x] Implement `delete<T>(endpoint: string)` method
  - [x] All methods use generic `request<T>()` internally

- [x] Implement retry logic with exponential backoff (AC: 5)
  - [x] Create `retryWithBackoff()` helper function
  - [x] Retry only on network errors (not 4xx/5xx responses)
  - [x] Max 3 retry attempts
  - [x] Exponential backoff: 1s, 2s, 4s delays
  - [x] Wrap `request()` method with retry logic
  - [x] Log retry attempts in development mode

- [x] Add request/response interceptors (AC: 7)
  - [x] Create `logRequest()` helper (logs in dev mode only)
  - [x] Create `logResponse()` helper (logs in dev mode only)
  - [x] Log endpoint, method, status code, response time
  - [x] Conditionally call loggers based on NODE_ENV

- [x] Write unit tests for API client (AC: 2, 4, 5)
  - [x] Test successful request returns typed data
  - [x] Test 4xx error throws APIError with correct status code
  - [x] Test 5xx error throws APIError
  - [x] Test network failure throws NetworkError
  - [x] Test timeout throws TimeoutError after 30s
  - [x] Test retry logic attempts 3 times for network errors
  - [x] Test retry does NOT occur for 4xx/5xx errors
  - [x] Mock fetch with Vitest

- [x] Create singleton API client instance (AC: 1)
  - [x] Export default instance: `export const apiClient = new APIClient()`
  - [x] Export class for testing: `export { APIClient }`

## Dev Notes

### Previous Story Context
- Story 2.1 and 2.2 created backend with Pydantic models and /api/chat endpoint
- Backend returns JSON matching ChatResponse schema
- Epic 1 created TypeScript enums and Zod schemas in `lib/enums.ts` and `lib/schemas.ts`

### Frontend Architecture Pattern
[Source: docs/architecture/9-frontend-architecture.md#93-api-client]

**API Client Structure:**
```typescript
// lib/api-client.ts
export class APIClient {
  private baseUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

  async request<T>(endpoint: string, options: RequestInit): Promise<T> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);

    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorText = await response.text();
        throw new APIError(response.status, errorText);
      }

      return await response.json() as T;
    } catch (error) {
      if (error instanceof DOMException && error.name === 'AbortError') {
        throw new TimeoutError('Request timed out after 30 seconds');
      }
      throw error;
    }
  }

  async post<T>(endpoint: string, data: unknown): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
  }
}

export const apiClient = new APIClient();
```

### Error Handling Strategy
[Source: docs/architecture/17-error-handling-strategy.md#172-frontend-error-handling]

**Custom Error Classes:**
```typescript
// lib/errors.ts
export class APIError extends Error {
  constructor(
    public statusCode: number,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'APIError';
  }
}

export class ValidationError extends Error {
  constructor(message: string, public errors: unknown) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class NetworkError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'NetworkError';
  }
}

export class TimeoutError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'TimeoutError';
  }
}
```

### Retry Logic Pattern
Exponential backoff with max 3 attempts:

```typescript
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      // Only retry on network errors, not API errors (4xx/5xx)
      if (error instanceof APIError) {
        throw error;
      }

      if (attempt < maxRetries - 1) {
        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError!;
}
```

### File Locations
[Source: docs/architecture/9-frontend-architecture.md#91-component-organization]

**Create these files:**
```
orchestratai_client/src/lib/
├── api-client.ts         # Base HTTP client class
└── errors.ts             # Custom error classes
```

**Test files:**
```
orchestratai_client/src/lib/
└── __tests__/
    └── api-client.test.ts
```

### Technical Constraints
[Source: docs/architecture/3-tech-stack.md]

- TypeScript: 5.6+
- Runtime: Bun 1.1+
- Testing: Vitest
- No external HTTP libraries (use native fetch)

### Environment Variables
[Source: docs/architecture/12-development-workflow.md#124-environment-variables]

**Frontend .env.local:**
```
NEXT_PUBLIC_API_URL=http://localhost:8000
```

**Docker network (Server Components):**
API accessible at `http://backend:8000` (internal Docker network).

**Browser (Client Components):**
API accessible at `http://localhost:8000` (exposed port).

### Coding Standards
[Source: docs/architecture/16-coding-standards.md#161-critical-rules]

- **Naming:** camelCase for functions (`sendMessage`), PascalCase for classes (`APIClient`)
- **Error handling:** Use custom error classes, never silent failures
- **Type safety:** All request/response must be typed with generics

### Testing

[Source: docs/architecture/15-testing-strategy.md#152-test-examples]

**Test Framework:** Vitest
**Test Location:** `orchestratai_client/src/lib/__tests__/api-client.test.ts`
**Test Type:** Unit tests (70% of test pyramid)

**Test Pattern:**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { APIClient, APIError, NetworkError, TimeoutError } from '../api-client';

describe('APIClient', () => {
  let apiClient: APIClient;

  beforeEach(() => {
    apiClient = new APIClient();
    vi.clearAllMocks();
  });

  it('should make successful GET request', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => ({ data: 'test' }),
    });

    const result = await apiClient.get('/test');
    expect(result).toEqual({ data: 'test' });
  });

  it('should throw APIError on 4xx response', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 400,
      text: async () => 'Bad Request',
    });

    await expect(apiClient.get('/test')).rejects.toThrow(APIError);
  });

  it('should retry on network error', async () => {
    global.fetch = vi.fn()
      .mockRejectedValueOnce(new Error('Network error'))
      .mockRejectedValueOnce(new Error('Network error'))
      .mockResolvedValue({ ok: true, json: async () => ({ data: 'test' }) });

    const result = await apiClient.get('/test');
    expect(global.fetch).toHaveBeenCalledTimes(3);
    expect(result).toEqual({ data: 'test' });
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Initial story creation | Scrum Master (Bob) |
| 2025-10-26 | 1.1 | Implementation completed - API client with error handling and retry logic | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
None - implementation completed without issues

### Completion Notes List
- Created custom error classes (APIError, ValidationError, NetworkError, TimeoutError) with proper error handling
- Implemented APIClient class with generic request method supporting TypeScript generics
- Added AbortController-based timeout mechanism (30s default, configurable)
- Implemented automatic retry logic with exponential backoff (1s, 2s, 4s) for network errors only
- Added development-mode logging for request/response debugging
- All HTTP methods (GET, POST, PUT, DELETE) implemented and tested
- Comprehensive test suite with 33 tests covering all error scenarios and retry logic
- All tests passing, linting clean, type checking successful
- Full regression suite passes (129 tests total)

### File List
**New Files:**
- `orchestratai_client/src/lib/errors.ts` - Custom error classes
- `orchestratai_client/src/lib/api-client.ts` - Base API client with retry logic
- `orchestratai_client/src/lib/__tests__/errors.test.ts` - Error class tests (14 tests)
- `orchestratai_client/src/lib/__tests__/api-client.test.ts` - API client tests (19 tests)

## QA Results

### Review Date: 2025-10-26

### Reviewed By: Quinn (Test Architect)

### Executive Summary

**Gate Status: ✓ PASS** - Excellent implementation with comprehensive test coverage, proper error handling architecture, and full compliance with coding standards.

### Code Quality Assessment

This implementation represents **exemplary quality** for infrastructure-layer code:

**Strengths:**
- **Type Safety Excellence**: Full TypeScript generics usage throughout, ensuring compile-time type checking for all API responses
- **Clean Architecture**: Proper separation of concerns with error classes isolated from client logic
- **Error Handling Mastery**: Well-designed error hierarchy with ValidationError extending APIError, stack trace preservation via Error.captureStackTrace
- **Resource Management**: Proper cleanup with clearTimeout in all code paths (success and error)
- **Developer Experience**: Comprehensive JSDoc comments and development-mode logging
- **Testability**: Highly testable design with dependency injection support

**Design Patterns Observed:**
- Singleton pattern for shared client instance
- Private methods for encapsulation (request() method)
- Exponential backoff for retry resilience
- Proper use of AbortController for cancellation

### Requirements Traceability (100% Coverage)

All 8 acceptance criteria mapped to comprehensive test coverage using Given-When-Then validation:

| AC | Requirement | Test Coverage | Status |
|---|---|---|---|
| 1 | Base API client with generic request | api-client.test.ts:38-125 (GET/POST/PUT/DELETE) | ✓ |
| 2 | Custom error classes | errors.test.ts:14-125 (4 error types) | ✓ |
| 3 | Type validation with generics | api-client.test.ts:38-125 (all methods) | ✓ |
| 4 | Request timeout (30s, configurable) | api-client.test.ts:189-220, 317-325 | ✓ |
| 5 | Retry logic (3 attempts, exp backoff) | api-client.test.ts:224-278 | ✓ |
| 6 | Environment variable base URL | api-client.test.ts:282-315 | ✓ |
| 7 | Development-only logging | api-client.test.ts:329-361 | ✓ |
| 8 | Error with status/message/details | errors.test.ts:26-44, api-client.test.ts:129-179 | ✓ |

**Traceability Details:**

**AC1 - Generic Request Method:**
- *Given* an APIClient instance
- *When* making typed HTTP requests (GET/POST/PUT/DELETE)
- *Then* generic request<T>() returns properly typed responses
- Tests: 4 HTTP method tests with type validation

**AC2 - Custom Error Classes:**
- *Given* various error scenarios
- *When* errors occur during API calls
- *Then* specific error types thrown (APIError, ValidationError, NetworkError, TimeoutError)
- Tests: 14 comprehensive error class tests

**AC3 - Response Type Validation:**
- *Given* API responses
- *When* JSON is parsed
- *Then* responses validated against TypeScript generics
- Tests: All successful request tests verify typing

**AC4 - Request Timeout:**
- *Given* slow API responses
- *When* timeout duration exceeded
- *Then* TimeoutError thrown with proper message
- Tests: AbortController simulation with realistic timeout scenarios

**AC5 - Retry Logic:**
- *Given* network errors
- *When* request fails
- *Then* retry 3 times with 1s, 2s, 4s delays (no retry for 4xx/5xx)
- Tests: 3 retry tests covering success, failure, and API error non-retry

**AC6 - Environment Configuration:**
- *Given* NEXT_PUBLIC_API_URL environment variable
- *When* APIClient instantiated
- *Then* uses env var or defaults to http://localhost:8000
- Tests: Environment variable tests with proper cleanup

**AC7 - Development Logging:**
- *Given* NODE_ENV setting
- *When* making requests
- *Then* logs only in development mode
- Tests: Separate tests for dev and production modes

**AC8 - Error Response Structure:**
- *Given* API errors
- *When* error responses received
- *Then* errors include statusCode, message, and optional details
- Tests: Error construction and property tests

### Refactoring Performed

**No refactoring required.** The implementation is clean, follows best practices, and requires no modifications.

### Compliance Check

- **Coding Standards (16-coding-standards.md)**: ✓ PASS
  - Naming conventions: camelCase for functions (retryWithBackoff, logRequest), PascalCase for classes (APIClient, APIError)
  - Error handling: Custom error classes with proper hierarchy, no silent failures
  - Type safety: Full generic typing throughout

- **Project Structure**: ✓ PASS
  - Files in correct locations: `orchestratai_client/src/lib/`
  - Test files properly organized: `__tests__/` subdirectory
  - Follows documented patterns from docs/architecture/9-frontend-architecture.md

- **Testing Strategy (15-testing-strategy.md)**: ✓ PASS
  - Test pyramid: 100% unit tests (appropriate for infrastructure layer)
  - Vitest framework used correctly
  - Proper test structure with describe/it/expect
  - 33 tests with excellent edge case coverage

- **Error Handling Strategy (17-error-handling-strategy.md)**: ✓ PASS with minor note
  - Custom error classes implemented correctly
  - Proper error hierarchy
  - Stack trace preservation
  - **Minor note**: Template shows optional `userMessage` and `shouldRetry` helper methods not implemented (not required by ACs, can be added later for UI integration)

- **All ACs Met**: ✓ YES (8/8 = 100%)

### Test Architecture Assessment

**Test Quality: EXCELLENT**

**Coverage Metrics:**
- Total tests: 33 (14 error tests + 19 API client tests)
- Test pyramid compliance: ✓ 100% unit tests (appropriate for infrastructure)
- Acceptance criteria coverage: 8/8 (100%)
- Edge case coverage: Comprehensive (timeouts, retries, all HTTP methods, error scenarios)

**Test Design Highlights:**
1. **Proper Test Isolation**: beforeEach/afterEach cleanup ensures test independence
2. **Realistic Mocking**: AbortController simulation for timeout testing
3. **Behavior Testing**: Tests verify behavior, not implementation details
4. **Error Type Verification**: Proper use of instanceof for error type assertions
5. **Environment Testing**: Environment variable tests with proper cleanup
6. **Async Handling**: Appropriate test timeouts (10s) for long-running retry tests

**Test Reliability:**
- All 33 tests passing consistently
- No flaky tests observed
- Proper async/await handling
- Mock cleanup between tests

### Non-Functional Requirements (NFRs)

**Security: ✓ PASS**
- No credential handling at this layer (appropriate separation)
- Error messages don't expose stack traces to API responses
- No XSS/injection vectors
- Content-Type headers properly set
- No sensitive data logging

**Performance: ✓ PASS**
- Efficient retry logic with exponential backoff prevents thundering herd
- Singleton pattern for shared client instance (no repeated initialization)
- No unnecessary object creation in hot paths
- Timeout mechanism prevents hanging requests
- Minimal memory allocation during retries

**Reliability: ✓ PASS**
- Comprehensive error handling for all failure modes
- Graceful degradation with retry logic
- Proper resource cleanup (clearTimeout) in all code paths
- Network failure resilience with appropriate error types
- AbortController prevents resource leaks

**Maintainability: ✓ PASS**
- Clear, self-documenting code
- Extensive JSDoc comments on all public APIs
- Consistent naming conventions
- Testable architecture with DI support
- Clean separation of concerns
- Easy to extend for new HTTP methods or error types

### Testability Evaluation

**Controllability: EXCELLENT**
- Configurable timeout via constructor parameter
- Configurable baseUrl via constructor parameter
- Environment variables can be overridden in tests
- Dependency injection friendly design

**Observability: EXCELLENT**
- Development-mode logging for request/response debugging
- Specific error types enable precise error handling
- Contextual error messages with status codes
- Retry attempt logging in development mode
- Response time tracking in logs

**Debuggability: EXCELLENT**
- Stack traces preserved with Error.captureStackTrace
- Request/response logging shows method, endpoint, status, duration
- Retry attempt logging shows which attempt and delay
- Clear error messages indicate failure reason
- Type information available in IDE for all APIs

### Security Review

**Status: ✓ PASS - No security concerns**

**Analysis:**
- This is infrastructure layer code with no direct security implications
- No credential handling (appropriate - that belongs in higher layers)
- No user input processing beyond JSON serialization
- Error handling doesn't leak sensitive information
- No eval() or other dynamic code execution
- Content-Type headers prevent MIME sniffing attacks

**Best Practices Observed:**
- Error messages sanitized (uses response.text(), not exposing internals)
- No logging of sensitive data (request bodies not logged)
- Proper CORS handling (left to server, as appropriate)

### Performance Considerations

**Status: ✓ PASS - Well optimized**

**Performance Characteristics:**
- **Request latency**: Minimal overhead (~1-2ms) from error handling and logging
- **Retry behavior**: Exponential backoff prevents server overload (1s → 2s → 4s)
- **Memory usage**: Singleton pattern prevents duplicate client instances
- **Resource cleanup**: AbortController and clearTimeout prevent memory leaks
- **Network efficiency**: Only retries on network errors, not API errors (4xx/5xx)

**Scaling Considerations:**
- Client designed for high-concurrency usage
- No global state except singleton instance
- Each request uses isolated AbortController
- No request queuing (requests are independent)

### Technical Debt Assessment

**Status: ✓ ZERO technical debt identified**

**Analysis:**
- No shortcuts taken in implementation
- Complete test coverage (33 tests)
- No TODOs or FIXMEs in code
- Architecture aligns with project patterns
- No deprecated APIs used
- No hardcoded values (all configurable)
- No copy-paste code duplication

### Risk Assessment

**Overall Risk: LOW**

**Risk Breakdown:**
- **Critical**: 0 issues
- **High**: 0 issues
- **Medium**: 0 issues
- **Low**: 1 issue (optional enhancement, not blocking)

**Low Risk Item:**
- Consider adding `userMessage` and `shouldRetry` helper methods to APIError class for future UI integration (referenced in error-handling-strategy.md but not required by current ACs)

### Improvements Checklist

**All improvements completed during implementation:**
- [x] Custom error classes with proper hierarchy (errors.ts)
- [x] Full type safety with TypeScript generics (api-client.ts)
- [x] Comprehensive test coverage (33 tests, all passing)
- [x] Development-mode logging for debugging (api-client.ts:11-29)
- [x] Resource cleanup in all code paths (api-client.ts:116, 133)
- [x] Stack trace preservation for debugging (errors.ts:24-26, 41-43, 56-58, 69-71)

**Optional Future Enhancements (non-blocking):**
- [ ] Add `userMessage` getter to APIError for UI-friendly error messages (low priority)
- [ ] Add `shouldRetry` getter to APIError for programmatic retry decisions (low priority)
- [ ] Consider request/response interceptor hooks for auth token injection (future feature)
- [ ] Consider adding request caching layer (performance optimization for future)

### Files Modified During Review

**No files modified during review.** The implementation is production-ready as-is.

### Gate Status

**Gate: PASS** → [docs/qa/gates/2.3-frontend-api-client.yml](../qa/gates/2.3-frontend-api-client.yml)

**Quality Score: 100/100**

**Gate Decision Rationale:**
- ✓ All 8 acceptance criteria fully implemented and tested
- ✓ 100% requirements traceability (8/8 ACs mapped to tests)
- ✓ Comprehensive test coverage (33 tests, all passing)
- ✓ No critical, high, or medium risk issues
- ✓ All NFRs met (security, performance, reliability, maintainability)
- ✓ Full compliance with coding standards and testing strategy
- ✓ Zero technical debt
- ✓ Excellent testability (controllability, observability, debuggability)

**Risk Summary:**
- Critical: 0
- High: 0
- Medium: 0
- Low: 1 (optional enhancement for future UI integration)

**Expiration:** 2025-11-09 (2 weeks from review)

### Recommended Status

**✓ Ready for Done**

This story is **production-ready** and can be merged immediately. The implementation demonstrates exceptional quality with:
- Complete functional requirements (8/8 ACs)
- Comprehensive test coverage (33 tests)
- Zero blocking issues
- Full standards compliance
- Excellent architecture and design

**No changes required.** The optional enhancement (userMessage/shouldRetry methods) can be addressed in a future story if/when UI integration requires it.

### Educational Notes

**Why This Implementation Excels:**

1. **Type Safety**: The generic `request<T>()` method ensures compile-time type checking, catching errors before runtime.

2. **Error Hierarchy**: ValidationError extending APIError allows callers to catch specific error types or fall back to generic API error handling.

3. **Retry Strategy**: Only retrying network errors (not 4xx/5xx) prevents infinite loops on client/server errors while providing resilience for transient network issues.

4. **Resource Management**: clearTimeout in all paths (success and error) prevents timer leaks that could accumulate over time.

5. **Development Experience**: Conditional logging provides debugging visibility in development without production overhead.

6. **Test Design**: Tests focus on behavior (what the API does) rather than implementation (how it does it), making tests resilient to refactoring.

**Key Learning**: This implementation showcases how infrastructure code should be written—type-safe, well-tested, resilient to failures, and easy to debug.
