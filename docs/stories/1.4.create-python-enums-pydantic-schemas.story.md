# Story 1.4: Create Python Enums and Pydantic Schemas

<!-- Powered by BMAD™ Core -->

## Status

**Draft**

---

## Story

**As a** Backend Developer,
**I want** to create Python enums that exactly mirror the TypeScript enums and Pydantic schemas for API validation,
**so that** the backend enforces type safety, validates incoming requests, and maintains perfect synchronization with the frontend type system.

---

## Acceptance Criteria

1. Python enum file `orchestratai_api/src/models/enums.py` created with 7 enums mirroring TypeScript
2. Enum `AgentStatus` defines states: IDLE, ROUTING, ACTIVE (matching TS exactly)
3. Enum `AgentId` defines agents: ORCHESTRATOR, BILLING, TECHNICAL, POLICY (matching TS exactly)
4. Enum `MessageRole` defines roles: USER, ASSISTANT (matching TS exactly)
5. Enum `LogType` defines types: ROUTING, VECTOR_SEARCH, CACHE, DOCUMENTS (matching TS exactly)
6. Enum `LogStatus` defines states: SUCCESS, WARNING, ERROR (matching TS exactly)
7. Enum `RetrievalStrategy` defines: PURE_RAG, PURE_CAG, HYBRID_RAG_CAG (matching TS exactly)
8. Enum `AgentColor` defines: CYAN, GREEN, BLUE, PURPLE (matching TS exactly)
9. All Python enums inherit from `str, Enum` for JSON serialization compatibility
10. Pydantic schema file `orchestratai_api/src/models/schemas.py` created
11. `ChatRequest` schema validates message (min 1, max 2000 chars) and session_id (UUID format)
12. `ChatResponse` schema validates complete API response structure
13. `Agent` schema validates agent data model with enum types
14. `Message` schema validates message data model with enum types
15. `RetrievalLog` schema validates retrieval log structure with enum types
16. `ChatMetrics` schema validates metrics with numeric constraints
17. `DocumentChunk` schema validates document chunk structure
18. All Pydantic models use `Field` validators with proper constraints
19. Python type hints are correct (mypy validation passes)
20. FastAPI can import and use schemas without errors

---

## Tasks / Subtasks

- [ ] **Task 1: Create Python Enums File** (AC: 1-9)
  - [ ] Create file `orchestratai_api/src/models/__init__.py` if not exists
  - [ ] Create file `orchestratai_api/src/models/enums.py`
  - [ ] Import Enum from Python standard library
  - [ ] Define `AgentStatus(str, Enum)` with IDLE = "idle", ROUTING = "routing", ACTIVE = "active"
  - [ ] Define `AgentId(str, Enum)` with ORCHESTRATOR = "orchestrator", BILLING = "billing", TECHNICAL = "technical", POLICY = "policy"
  - [ ] Define `MessageRole(str, Enum)` with USER = "user", ASSISTANT = "assistant"
  - [ ] Define `LogType(str, Enum)` with ROUTING = "routing", VECTOR_SEARCH = "vector_search", CACHE = "cache", DOCUMENTS = "documents"
  - [ ] Define `LogStatus(str, Enum)` with SUCCESS = "success", WARNING = "warning", ERROR = "error"
  - [ ] Define `RetrievalStrategy(str, Enum)` with PURE_RAG = "Pure RAG", PURE_CAG = "Pure CAG", HYBRID_RAG_CAG = "Hybrid RAG/CAG"
  - [ ] Define `AgentColor(str, Enum)` with CYAN = "cyan", GREEN = "green", BLUE = "blue", PURPLE = "purple"
  - [ ] Add docstrings explaining enum purpose
  - [ ] Add comment: "CRITICAL: These MUST match frontend enums exactly! Validation script will check."

- [ ] **Task 2: Create Pydantic Schemas** (AC: 10-17)
  - [ ] Create file `orchestratai_api/src/models/schemas.py`
  - [ ] Import BaseModel, Field from pydantic
  - [ ] Import typing utilities: List, Dict, Any, Optional
  - [ ] Import all enums from `.enums`
  - [ ] Create `ChatRequest` model with message (Field min_length=1, max_length=2000) and session_id (Field UUID regex)
  - [ ] Create `ChatMetrics` model with tokensUsed (>=0), cost (>=0), latency (>=0)
  - [ ] Create `DocumentChunk` model with id (int), content (str), similarity (0-1 float), source (str), metadata (Optional[Dict])
  - [ ] Create `RetrievalLog` model with id, type (LogType), title, data (Dict[str, Any]), timestamp (str), status (LogStatus), chunks (Optional[List[DocumentChunk]])
  - [ ] Create `Message` model with id, role (MessageRole), content, agent (Optional[AgentId]), confidence (Optional[float 0-1]), timestamp, sessionId
  - [ ] Create `Agent` model with id (AgentId), name, status (AgentStatus), model, strategy (Optional[RetrievalStrategy]), color (AgentColor), tokensUsed (int >=0), cost (float >=0), cached (Optional[bool])
  - [ ] Create `ChatResponse` model with message, agent (AgentId), confidence (float 0-1), logs (List[RetrievalLog]), metrics (ChatMetrics)
  - [ ] Add docstrings to all models explaining their purpose

- [ ] **Task 3: Add Field Validators and Constraints** (AC: 18)
  - [ ] Add Field validators for message length in ChatRequest
  - [ ] Add Field regex validator for session_id UUID format: `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`
  - [ ] Add Field ge=0 (greater than or equal) constraints for tokensUsed, cost, latency
  - [ ] Add Field ge=0, le=1 constraints for confidence and similarity scores
  - [ ] Add descriptive Field(..., description="...") for better API documentation

- [ ] **Task 4: Validate Python Type Checking** (AC: 19)
  - [ ] Run `mypy orchestratai_api/src/models/enums.py`
  - [ ] Run `mypy orchestratai_api/src/models/schemas.py`
  - [ ] Verify zero mypy type errors
  - [ ] Fix any type annotation issues

- [ ] **Task 5: Validate FastAPI Integration** (AC: 20)
  - [ ] Start Python interpreter in orchestratai_api directory
  - [ ] Import enums: `from src.models.enums import AgentId, AgentStatus`
  - [ ] Import schemas: `from src.models.schemas import ChatRequest, ChatResponse`
  - [ ] Create sample ChatRequest instance and validate it serializes to JSON
  - [ ] Verify Pydantic validation rejects invalid data (too long message, invalid UUID)
  - [ ] Confirm FastAPI can use schemas as response_model types

---

## Dev Notes

### Previous Story Insights

[Source: docs/stories/1.3.create-typescript-enums-zod-schemas.story.md - Requirements]

**Critical Synchronization Requirement:**
- **Python enums MUST match TypeScript enums EXACTLY**
- Enum names: Must be identical (e.g., `AgentStatus` in both TS and Python)
- Enum values: Must be identical strings (e.g., `IDLE = "idle"` in both)
- Validation script in Story 1.5 will enforce this synchronization
- Any mismatch will fail pre-commit hooks and CI/CD

**TypeScript Enum Values (MUST MATCH):**
```typescript
// From Story 1.3
export enum AgentStatus { IDLE = 'idle', ROUTING = 'routing', ACTIVE = 'active' }
export enum AgentId { ORCHESTRATOR = 'orchestrator', BILLING = 'billing', TECHNICAL = 'technical', POLICY = 'policy' }
export enum MessageRole { USER = 'user', ASSISTANT = 'assistant' }
export enum LogType { ROUTING = 'routing', VECTOR_SEARCH = 'vector_search', CACHE = 'cache', DOCUMENTS = 'documents' }
export enum LogStatus { SUCCESS = 'success', WARNING = 'warning', ERROR = 'error' }
export enum RetrievalStrategy { PURE_RAG = 'Pure RAG', PURE_CAG = 'Pure CAG', HYBRID_RAG_CAG = 'Hybrid RAG/CAG' }
export enum AgentColor { CYAN = 'cyan', GREEN = 'green', BLUE = 'blue', PURPLE = 'purple' }
```

### Tech Stack Context

[Source: docs/architecture/3-tech-stack.md]

**Backend Stack:**
- **Python**: 3.12 (latest stable)
- **FastAPI**: 0.115+ (async support, auto OpenAPI docs)
- **Pydantic**: v2.x (comes with FastAPI, automatic validation)
- **Package Manager**: uv (10-100x faster than pip)
- **Type Checking**: mypy (for static type analysis)

**Why Pydantic?**
- Automatic request/response validation in FastAPI
- Runtime validation prevents invalid data from entering system
- Auto-generates OpenAPI schema documentation
- Type hints provide IDE autocomplete and mypy checking
- Seamless integration with FastAPI's dependency injection

### Python Enum Best Practices

[Source: docs/prd/orchestratai_prd_v2.md - Section 8.4]

**Critical Pattern: Inherit from `str, Enum`**

```python
# ✅ CORRECT: Inherit from str, Enum for JSON serialization
from enum import Enum

class AgentStatus(str, Enum):
    IDLE = "idle"
    ROUTING = "routing"
    ACTIVE = "active"

# ❌ WRONG: Plain Enum doesn't serialize to JSON properly
class AgentStatus(Enum):
    IDLE = "idle"  # Will serialize as AgentStatus.IDLE, not "idle"
```

**Why `str, Enum`?**
- FastAPI automatically converts to/from JSON strings
- Pydantic can validate against enum values
- Database storage as string (when we add PostgreSQL later)
- Frontend receives clean string values, not enum objects

### Pydantic Schema Patterns

[Source: docs/prd/orchestratai_prd_v2.md - Section 8.4]

**Correct Field Validator Patterns:**

```python
from pydantic import BaseModel, Field
from typing import Optional

# ✅ CORRECT: Field validators with constraints
class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, max_length=2000, description="User message")
    session_id: str = Field(
        ...,
        pattern=r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
        description="Chat session UUID"
    )

# ✅ CORRECT: Numeric constraints
class ChatMetrics(BaseModel):
    tokensUsed: int = Field(..., ge=0, description="Total tokens consumed")
    cost: float = Field(..., ge=0, description="Cost in USD")
    latency: int = Field(..., ge=0, description="Response time in milliseconds")

# ✅ CORRECT: Optional fields with defaults
class Agent(BaseModel):
    id: AgentId
    name: str
    status: AgentStatus
    strategy: Optional[RetrievalStrategy] = None  # Optional for Orchestrator
    cached: Optional[bool] = None

# ✅ CORRECT: Nested models
class ChatResponse(BaseModel):
    message: str
    agent: AgentId
    confidence: float = Field(..., ge=0, le=1)
    logs: list[RetrievalLog]  # Python 3.12 allows list[] instead of List[]
    metrics: ChatMetrics
```

**Pydantic v2 Features:**
- Use `Field(...)` for required fields (not `Field(default=...)`)
- Use `Field(ge=0, le=1)` for numeric constraints
- Use `Field(pattern=r"regex")` for string validation
- Use `Field(description="...")` for OpenAPI docs
- Use `Optional[Type] = None` for optional fields

### File Structure Context

[Source: docs/architecture/source-tree.md, docs/architecture/10-backend-architecture.md]

**Backend File Locations:**
```
orchestratai_api/src/
├── models/
│   ├── __init__.py          # Package marker (create if not exists)
│   ├── enums.py             # Python enums (THIS STORY)
│   └── schemas.py           # Pydantic models (THIS STORY)
├── api/
│   ├── __init__.py
│   └── routes/
│       ├── __init__.py
│       ├── health.py        # Already exists
│       └── chat.py          # Will use schemas in Epic 2
├── services/
│   ├── __init__.py
│   └── mock_data.py         # Will use schemas in Epic 2
└── main.py                  # FastAPI app entry point
```

**Naming Conventions:**
- Files: snake_case (e.g., `enums.py`, `schemas.py`)
- Classes: PascalCase (e.g., `ChatRequest`, `AgentStatus`)
- Functions: snake_case (e.g., `generate_mock_response`)
- Enum values: SCREAMING_SNAKE_CASE for keys, lowercase strings for values

### Data Model Specifications

[Source: docs/architecture/4-data-models.md]

**Complete Python Schema Specifications:**

**ChatRequest:**
```python
class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, max_length=2000)
    session_id: str = Field(..., pattern=r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$')
```

**ChatResponse:**
```python
class ChatResponse(BaseModel):
    message: str
    agent: AgentId
    confidence: float = Field(..., ge=0, le=1)
    logs: list[RetrievalLog]
    metrics: ChatMetrics
```

**Agent:**
```python
class Agent(BaseModel):
    id: AgentId
    name: str
    status: AgentStatus
    model: str
    strategy: Optional[RetrievalStrategy] = None
    color: AgentColor
    tokensUsed: int = Field(..., ge=0)
    cost: float = Field(..., ge=0)
    cached: Optional[bool] = None
```

**Message:**
```python
class Message(BaseModel):
    id: str  # UUID
    role: MessageRole
    content: str
    agent: Optional[AgentId] = None
    confidence: Optional[float] = Field(None, ge=0, le=1)
    timestamp: str  # ISO 8601 string
    sessionId: str  # UUID
```

**RetrievalLog:**
```python
class RetrievalLog(BaseModel):
    id: str
    type: LogType
    title: str
    data: dict[str, Any]
    timestamp: str  # ISO 8601
    status: LogStatus
    chunks: Optional[list[DocumentChunk]] = None
```

**DocumentChunk:**
```python
class DocumentChunk(BaseModel):
    id: int
    content: str
    similarity: float = Field(..., ge=0, le=1)
    source: str
    metadata: Optional[dict[str, Any]] = None
```

**ChatMetrics:**
```python
class ChatMetrics(BaseModel):
    tokensUsed: int = Field(..., ge=0)
    cost: float = Field(..., ge=0)
    latency: int = Field(..., ge=0)
```

### Coding Standards Compliance

[Source: docs/architecture/16-coding-standards.md]

**Critical Rules:**
- **Enum Sync**: Python enums MUST match TypeScript enums exactly (validated in Story 1.5)
- **Type Hints**: All functions and variables MUST have type hints for mypy
- **Docstrings**: All classes MUST have docstrings explaining purpose
- **Field Validators**: Use Pydantic Field(...) for all constraints

**Python Naming Conventions:**
- Modules: snake_case (enums.py, schemas.py)
- Classes: PascalCase (ChatRequest, AgentStatus)
- Functions: snake_case (generate_mock_response)
- Constants: SCREAMING_SNAKE_CASE

### Testing Standards

[Source: docs/architecture/15-testing-strategy.md]

**Testing Approach for This Story:**
- **Manual validation ONLY** - No pytest unit tests required for schema definitions
- **Validation checklist**:
  1. mypy type checking passes with zero errors
  2. Python can import enums and schemas without errors
  3. Pydantic validates sample data correctly
  4. Pydantic rejects invalid data with clear error messages
  5. FastAPI can use schemas as request/response models

**Future Testing** (Epic 2+):
- pytest tests will validate API endpoints using these schemas
- Test location: `orchestratai_api/tests/test_schemas.py`
- Integration tests will validate end-to-end request/response flow

### Development Environment

[Source: docs/prd/orchestratai_prd_v2.md - Section 0]

**Backend Development Setup:**
- **Package Manager**: Use `uv` for all Python package management (NOT pip)
- **Python Version**: 3.12 (specified in `.python-version`)
- **Docker**: Backend runs in Docker container (hot reload enabled)
- **Development Server**: http://localhost:8000
- **API Docs**: http://localhost:8000/docs (auto-generated from Pydantic schemas)

**Commands:**
```bash
# Start backend in Docker
docker compose up backend

# Or run directly (for development)
cd orchestratai_api
uv sync  # Install dependencies
python -m src.main  # Run server

# Type checking
mypy orchestratai_api/src/models/

# Python REPL for testing
python
>>> from src.models.enums import AgentId
>>> from src.models.schemas import ChatRequest
```

### Python 3.12 Type Hints

[Source: docs/architecture/3-tech-stack.md]

**Use Modern Python 3.12 Syntax:**

```python
# ✅ CORRECT: Python 3.12 allows lowercase type hints
from typing import Optional

def process_logs(logs: list[str]) -> dict[str, int]:
    return {"count": len(logs)}

class ChatResponse(BaseModel):
    logs: list[RetrievalLog]  # Python 3.12 syntax
    metrics: ChatMetrics

# ❌ WRONG: Old syntax (still works but unnecessary)
from typing import List, Dict

def process_logs(logs: List[str]) -> Dict[str, int]:
    return {"count": len(logs)}
```

**Type Hint Best Practices:**
- Use `list[]` instead of `List[]` (Python 3.12+)
- Use `dict[]` instead of `Dict[]` (Python 3.12+)
- Use `Optional[Type]` for optional fields
- Use `Any` from typing for arbitrary JSON data
- Use `Field(...)` for Pydantic constraints

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Initial story creation for Python enums and Pydantic schemas | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

*To be completed by Dev Agent*

### Debug Log References

*To be completed by Dev Agent*

### Completion Notes

*To be completed by Dev Agent*

### File List

*To be completed by Dev Agent*

---

## QA Results

*To be completed by QA Agent*
