# <!-- Powered by BMAD™ Core -->

## Status
Draft

## Story
**As a** user,
**I want** my chat history and agent state saved to Redis,
**so that** my conversation persists if I refresh the page or return later

## Acceptance Criteria
1. New endpoint: `POST /api/session` saves session data
2. New endpoint: `GET /api/session/{session_id}` loads session
3. New endpoint: `DELETE /api/session/{session_id}` clears session
4. Session data includes: messages, agent state, logs
5. Data stored in Redis with 24-hour TTL
6. Session key format: `session:{uuid}`
7. Data serialized as JSON
8. Handle Redis connection errors gracefully
9. Fallback to in-memory if Redis unavailable
10. Session saved after each chat message
11. Session auto-expires after 24 hours
12. Redis client properly configured (already in docker-compose)

## Tasks / Subtasks

- [ ] Task 1: Create session service module (AC: 4, 5, 6, 7, 8, 9)
  - [ ] Create `orchestratai_service/src/services/session_service.py`
  - [ ] Import redis library and dependencies
  - [ ] Define SessionData TypedDict with all fields
  - [ ] Initialize Redis client with connection config
  - [ ] Add connection timeout and retry logic
  - [ ] Implement connection error handling
  - [ ] Add fallback to in-memory dict if Redis unavailable
  - [ ] Add logging for Redis operations

- [ ] Task 2: Implement save_session function (AC: 1, 5, 6, 7, 10)
  - [ ] Define `save_session(session_id: str, data: dict)` function
  - [ ] Validate session_id format (UUID)
  - [ ] Construct Redis key: `session:{session_id}`
  - [ ] Serialize data to JSON
  - [ ] Use `setex` to save with 24-hour TTL
  - [ ] Handle serialization errors
  - [ ] Handle Redis connection errors
  - [ ] Return success/failure status
  - [ ] Add logging for save operations

- [ ] Task 3: Implement load_session function (AC: 2, 6, 7)
  - [ ] Define `load_session(session_id: str) -> dict | None` function
  - [ ] Validate session_id format
  - [ ] Construct Redis key: `session:{session_id}`
  - [ ] Use `get` to retrieve data
  - [ ] Deserialize JSON to dict
  - [ ] Return None if session not found (expired)
  - [ ] Handle deserialization errors
  - [ ] Handle Redis connection errors
  - [ ] Add logging for load operations

- [ ] Task 4: Implement delete_session function (AC: 3, 6)
  - [ ] Define `delete_session(session_id: str)` function
  - [ ] Validate session_id format
  - [ ] Construct Redis key: `session:{session_id}`
  - [ ] Use `delete` to remove session
  - [ ] Handle Redis connection errors
  - [ ] Return success/failure status
  - [ ] Add logging for delete operations

- [ ] Task 5: Create session API router (AC: 1, 2, 3)
  - [ ] Create `orchestratai_service/src/api/routes/session.py`
  - [ ] Import FastAPI dependencies (APIRouter, HTTPException)
  - [ ] Import session_service functions
  - [ ] Define Pydantic models for request/response
  - [ ] Create APIRouter instance
  - [ ] Add route decorators for POST, GET, DELETE
  - [ ] Export router

- [ ] Task 6: Implement POST /api/session endpoint (AC: 1, 4, 10)
  - [ ] Define `save_session_endpoint` function
  - [ ] Accept SessionSaveRequest body (session_id, data)
  - [ ] Validate request data with Pydantic
  - [ ] Call `session_service.save_session()`
  - [ ] Return SessionSaveResponse with success status
  - [ ] Handle errors with HTTPException (500)
  - [ ] Add request logging

- [ ] Task 7: Implement GET /api/session/{session_id} endpoint (AC: 2, 4)
  - [ ] Define `load_session_endpoint` function
  - [ ] Accept session_id path parameter
  - [ ] Call `session_service.load_session()`
  - [ ] If found: return SessionLoadResponse with data
  - [ ] If not found: raise HTTPException 404
  - [ ] Handle errors with HTTPException (500)
  - [ ] Add request logging

- [ ] Task 8: Implement DELETE /api/session/{session_id} endpoint (AC: 3)
  - [ ] Define `delete_session_endpoint` function
  - [ ] Accept session_id path parameter
  - [ ] Call `session_service.delete_session()`
  - [ ] Return SessionDeleteResponse with success status
  - [ ] Handle errors with HTTPException (500)
  - [ ] Add request logging

- [ ] Task 9: Register session router in main app (AC: 1, 2, 3)
  - [ ] Open `orchestratai_service/src/api/main.py`
  - [ ] Import session router
  - [ ] Register router with app: `app.include_router(session_router)`
  - [ ] Verify routes appear in OpenAPI docs
  - [ ] Test all endpoints with curl/Postman

- [ ] Task 10: Add error handling and fallback (AC: 8, 9)
  - [ ] Add try/except around all Redis operations
  - [ ] Implement in-memory dict fallback (temporary storage)
  - [ ] Log Redis connection failures
  - [ ] Return graceful error messages to client
  - [ ] Don't crash application if Redis unavailable
  - [ ] Test with Redis stopped

- [ ] Task 11: Write comprehensive tests (AC: All)
  - [ ] Test save_session saves to Redis with TTL
  - [ ] Test load_session retrieves correct data
  - [ ] Test load_session returns None for expired session
  - [ ] Test delete_session removes session
  - [ ] Test Redis connection error handling
  - [ ] Test fallback to in-memory storage
  - [ ] Test all API endpoints (POST, GET, DELETE)
  - [ ] Test session data structure
  - [ ] Mock Redis client for unit tests
  - [ ] Achieve 90%+ coverage

## Dev Notes

### Previous Story Context
From Story 2.7 (Chat State Management):
- Chat messages stored in React state
- Agent state tracked in context
- No persistence across page refreshes

From Story 3.6 (Build Log Visualization):
- Logs displayed in real-time
- Log data structure defined
- No persistence for logs

### Architecture References

**Redis Configuration** [Source: docker-compose.yml]
Redis service already configured in Docker Compose:
```yaml
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
```

**Backend Stack** [Source: architecture/3-tech-stack.md]
- FastAPI for REST endpoints
- Python 3.11+
- redis-py library for Redis client
- Pydantic for data validation

**Session Requirements** [Source: Epic 5 spec]
- 24-hour TTL (86400 seconds)
- Session key format: `session:{uuid}`
- JSON serialization for data
- Graceful error handling

### Code Examples

**Session Service** (services/session_service.py):
```python
"""
Session persistence service using Redis
Stores chat history, agent state, and logs
"""

import redis
import json
from datetime import timedelta
from typing import Optional, Dict, Any
from uuid import UUID
import logging

logger = logging.getLogger(__name__)

# Redis client configuration
# Using 'redis' as hostname (Docker service name)
redis_client = redis.Redis(
    host='redis',
    port=6379,
    decode_responses=True,  # Auto-decode bytes to strings
    socket_connect_timeout=5,
    socket_timeout=5,
    retry_on_timeout=True,
)

# Fallback in-memory storage (if Redis unavailable)
memory_store: Dict[str, str] = {}

# Session TTL (24 hours)
SESSION_TTL = timedelta(hours=24)


def _is_redis_available() -> bool:
    """Check if Redis connection is available"""
    try:
        redis_client.ping()
        return True
    except redis.ConnectionError:
        logger.warning("Redis connection unavailable, using in-memory fallback")
        return False


def _validate_session_id(session_id: str) -> bool:
    """Validate session ID is a valid UUID"""
    try:
        UUID(session_id)
        return True
    except ValueError:
        return False


async def save_session(session_id: str, data: Dict[str, Any]) -> bool:
    """
    Save session data to Redis with 24-hour TTL

    Args:
        session_id: Unique session identifier (UUID)
        data: Session data including messages, agents, logs

    Returns:
        bool: True if saved successfully, False otherwise
    """
    if not _validate_session_id(session_id):
        logger.error(f"Invalid session ID: {session_id}")
        return False

    key = f"session:{session_id}"

    try:
        # Serialize data to JSON
        json_data = json.dumps(data)

        # Try Redis first
        if _is_redis_available():
            redis_client.setex(
                key,
                SESSION_TTL,
                json_data
            )
            logger.info(f"Session saved to Redis: {session_id}")
        else:
            # Fallback to in-memory
            memory_store[key] = json_data
            logger.info(f"Session saved to memory: {session_id}")

        return True

    except json.JSONEncodeError as e:
        logger.error(f"Failed to serialize session data: {e}")
        return False
    except redis.RedisError as e:
        logger.error(f"Redis error saving session: {e}")
        # Try fallback
        try:
            memory_store[key] = json_data
            logger.info(f"Session saved to memory fallback: {session_id}")
            return True
        except Exception as e2:
            logger.error(f"Fallback save failed: {e2}")
            return False


async def load_session(session_id: str) -> Optional[Dict[str, Any]]:
    """
    Load session data from Redis

    Args:
        session_id: Unique session identifier (UUID)

    Returns:
        dict: Session data if found, None if not found or expired
    """
    if not _validate_session_id(session_id):
        logger.error(f"Invalid session ID: {session_id}")
        return None

    key = f"session:{session_id}"

    try:
        # Try Redis first
        if _is_redis_available():
            json_data = redis_client.get(key)
            if json_data:
                data = json.loads(json_data)
                logger.info(f"Session loaded from Redis: {session_id}")
                return data
        else:
            # Fallback to in-memory
            json_data = memory_store.get(key)
            if json_data:
                data = json.loads(json_data)
                logger.info(f"Session loaded from memory: {session_id}")
                return data

        logger.info(f"Session not found: {session_id}")
        return None

    except json.JSONDecodeError as e:
        logger.error(f"Failed to deserialize session data: {e}")
        return None
    except redis.RedisError as e:
        logger.error(f"Redis error loading session: {e}")
        # Try fallback
        try:
            json_data = memory_store.get(key)
            if json_data:
                data = json.loads(json_data)
                logger.info(f"Session loaded from memory fallback: {session_id}")
                return data
        except Exception as e2:
            logger.error(f"Fallback load failed: {e2}")
        return None


async def delete_session(session_id: str) -> bool:
    """
    Delete session data from Redis

    Args:
        session_id: Unique session identifier (UUID)

    Returns:
        bool: True if deleted successfully, False otherwise
    """
    if not _validate_session_id(session_id):
        logger.error(f"Invalid session ID: {session_id}")
        return False

    key = f"session:{session_id}"

    try:
        # Try Redis first
        if _is_redis_available():
            result = redis_client.delete(key)
            logger.info(f"Session deleted from Redis: {session_id} (result: {result})")
        else:
            # Fallback to in-memory
            if key in memory_store:
                del memory_store[key]
                logger.info(f"Session deleted from memory: {session_id}")

        return True

    except redis.RedisError as e:
        logger.error(f"Redis error deleting session: {e}")
        # Try fallback
        try:
            if key in memory_store:
                del memory_store[key]
                logger.info(f"Session deleted from memory fallback: {session_id}")
        except Exception as e2:
            logger.error(f"Fallback delete failed: {e2}")
        return False
```

**Session API Router** (api/routes/session.py):
```python
"""
Session management API endpoints
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from typing import Dict, Any, List
import logging

from services import session_service

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/session", tags=["session"])


# Pydantic Models
class SessionSaveRequest(BaseModel):
    """Request body for saving session"""
    session_id: str = Field(..., description="Unique session identifier (UUID)")
    data: Dict[str, Any] = Field(..., description="Session data to save")


class SessionSaveResponse(BaseModel):
    """Response for session save"""
    success: bool
    message: str


class SessionLoadResponse(BaseModel):
    """Response for session load"""
    session_id: str
    data: Dict[str, Any]
    message: str


class SessionDeleteResponse(BaseModel):
    """Response for session delete"""
    success: bool
    message: str


@router.post("", response_model=SessionSaveResponse)
async def save_session_endpoint(request: SessionSaveRequest):
    """
    Save session data to Redis

    **Request Body:**
    ```json
    {
      "session_id": "uuid-string",
      "data": {
        "messages": [...],
        "agents": {...},
        "logs": [...]
      }
    }
    ```

    **Response:**
    ```json
    {
      "success": true,
      "message": "Session saved successfully"
    }
    ```
    """
    logger.info(f"Saving session: {request.session_id}")

    success = await session_service.save_session(
        request.session_id,
        request.data
    )

    if success:
        return SessionSaveResponse(
            success=True,
            message="Session saved successfully"
        )
    else:
        raise HTTPException(
            status_code=500,
            detail="Failed to save session"
        )


@router.get("/{session_id}", response_model=SessionLoadResponse)
async def load_session_endpoint(session_id: str):
    """
    Load session data from Redis

    **Path Parameters:**
    - `session_id`: UUID of the session to load

    **Response:**
    ```json
    {
      "session_id": "uuid-string",
      "data": {
        "messages": [...],
        "agents": {...},
        "logs": [...]
      },
      "message": "Session loaded successfully"
    }
    ```

    **Errors:**
    - `404`: Session not found (expired or doesn't exist)
    - `500`: Server error
    """
    logger.info(f"Loading session: {session_id}")

    data = await session_service.load_session(session_id)

    if data is None:
        raise HTTPException(
            status_code=404,
            detail=f"Session not found: {session_id}"
        )

    return SessionLoadResponse(
        session_id=session_id,
        data=data,
        message="Session loaded successfully"
    )


@router.delete("/{session_id}", response_model=SessionDeleteResponse)
async def delete_session_endpoint(session_id: str):
    """
    Delete session data from Redis

    **Path Parameters:**
    - `session_id`: UUID of the session to delete

    **Response:**
    ```json
    {
      "success": true,
      "message": "Session deleted successfully"
    }
    ```

    **Errors:**
    - `500`: Server error
    """
    logger.info(f"Deleting session: {session_id}")

    success = await session_service.delete_session(session_id)

    if success:
        return SessionDeleteResponse(
            success=True,
            message="Session deleted successfully"
        )
    else:
        raise HTTPException(
            status_code=500,
            detail="Failed to delete session"
        )
```

**Register Router in Main App** (api/main.py):
```python
from fastapi import FastAPI
from api.routes import session

app = FastAPI(title="OrchestratAI API")

# Register session router
app.include_router(session.router)

# ... other routers
```

**Session Data Structure**:
```python
# Example session data
{
    "session_id": "123e4567-e89b-12d3-a456-426614174000",
    "messages": [
        {
            "id": "msg-1",
            "role": "user",
            "content": "What is the billing policy?",
            "timestamp": "2025-11-01T10:00:00Z"
        },
        {
            "id": "msg-2",
            "role": "assistant",
            "content": "The billing policy...",
            "timestamp": "2025-11-01T10:00:05Z"
        }
    ],
    "agents": {
        "orchestrator": {
            "status": "idle",
            "model": "gpt-4o",
            "metrics": {"tokens": 1234, "cost": 0.05, "latency": 500}
        },
        "billing": {
            "status": "active",
            "model": "gpt-4o",
            "metrics": {"tokens": 567, "cost": 0.02, "latency": 300}
        }
    },
    "logs": [
        {
            "timestamp": "2025-11-01T10:00:02Z",
            "agent": "orchestrator",
            "event": "routing",
            "details": {"selected_agent": "billing"}
        }
    ],
    "last_updated": "2025-11-01T10:00:05Z"
}
```

**Test Example** (tests/test_session_service.py):
```python
import pytest
from unittest.mock import MagicMock, patch
from services import session_service

@pytest.fixture
def mock_redis():
    """Mock Redis client"""
    with patch('services.session_service.redis_client') as mock:
        mock.ping.return_value = True
        yield mock


@pytest.mark.asyncio
async def test_save_session_success(mock_redis):
    """Test saving session to Redis"""
    session_id = "123e4567-e89b-12d3-a456-426614174000"
    data = {"messages": [], "agents": {}, "logs": []}

    result = await session_service.save_session(session_id, data)

    assert result is True
    mock_redis.setex.assert_called_once()

    # Verify key format
    call_args = mock_redis.setex.call_args
    assert call_args[0][0] == f"session:{session_id}"


@pytest.mark.asyncio
async def test_load_session_success(mock_redis):
    """Test loading session from Redis"""
    session_id = "123e4567-e89b-12d3-a456-426614174000"
    expected_data = {"messages": [], "agents": {}, "logs": []}

    # Mock Redis return value
    mock_redis.get.return_value = json.dumps(expected_data)

    result = await session_service.load_session(session_id)

    assert result == expected_data
    mock_redis.get.assert_called_once_with(f"session:{session_id}")


@pytest.mark.asyncio
async def test_load_session_not_found(mock_redis):
    """Test loading non-existent session"""
    session_id = "123e4567-e89b-12d3-a456-426614174000"

    # Mock Redis returns None (not found)
    mock_redis.get.return_value = None

    result = await session_service.load_session(session_id)

    assert result is None


@pytest.mark.asyncio
async def test_delete_session_success(mock_redis):
    """Test deleting session from Redis"""
    session_id = "123e4567-e89b-12d3-a456-426614174000"

    result = await session_service.delete_session(session_id)

    assert result is True
    mock_redis.delete.assert_called_once_with(f"session:{session_id}")


@pytest.mark.asyncio
async def test_redis_connection_error_fallback():
    """Test fallback to in-memory storage when Redis unavailable"""
    with patch('services.session_service._is_redis_available', return_value=False):
        session_id = "123e4567-e89b-12d3-a456-426614174000"
        data = {"messages": [], "agents": {}, "logs": []}

        # Save should use in-memory fallback
        result = await session_service.save_session(session_id, data)
        assert result is True

        # Load should retrieve from in-memory
        loaded = await session_service.load_session(session_id)
        assert loaded == data
```

**API Test Example** (tests/test_session_api.py):
```python
import pytest
from fastapi.testclient import TestClient
from api.main import app

client = TestClient(app)


def test_save_session_endpoint():
    """Test POST /api/session"""
    request_data = {
        "session_id": "123e4567-e89b-12d3-a456-426614174000",
        "data": {
            "messages": [],
            "agents": {},
            "logs": []
        }
    }

    response = client.post("/api/session", json=request_data)

    assert response.status_code == 200
    assert response.json()["success"] is True


def test_load_session_endpoint():
    """Test GET /api/session/{session_id}"""
    session_id = "123e4567-e89b-12d3-a456-426614174000"

    # First save a session
    client.post("/api/session", json={
        "session_id": session_id,
        "data": {"messages": []}
    })

    # Then load it
    response = client.get(f"/api/session/{session_id}")

    assert response.status_code == 200
    assert response.json()["session_id"] == session_id
    assert "data" in response.json()


def test_load_session_not_found():
    """Test GET /api/session/{session_id} with non-existent session"""
    session_id = "00000000-0000-0000-0000-000000000000"

    response = client.get(f"/api/session/{session_id}")

    assert response.status_code == 404


def test_delete_session_endpoint():
    """Test DELETE /api/session/{session_id}"""
    session_id = "123e4567-e89b-12d3-a456-426614174000"

    # First save a session
    client.post("/api/session", json={
        "session_id": session_id,
        "data": {"messages": []}
    })

    # Then delete it
    response = client.delete(f"/api/session/{session_id}")

    assert response.status_code == 200
    assert response.json()["success"] is True

    # Verify it's deleted
    load_response = client.get(f"/api/session/{session_id}")
    assert load_response.status_code == 404
```

### File Structure
[Source: architecture/source-tree.md]

```
orchestratai_service/
├── src/
│   ├── services/
│   │   ├── __init__.py
│   │   ├── session_service.py          # NEW: Session persistence logic
│   │   └── __tests__/
│   │       └── test_session_service.py # NEW: Service tests
│   └── api/
│       ├── routes/
│       │   ├── __init__.py
│       │   ├── session.py              # NEW: Session API router
│       │   └── __tests__/
│       │       └── test_session_api.py # NEW: API tests
│       └── main.py                     # UPDATE: Register session router
└── requirements.txt                    # UPDATE: Ensure redis library included
```

### Integration Points
- Called from chat endpoint after each message (Story 2.7)
- Frontend will call GET /api/session on page load (Story 5.6)
- Clear endpoint called from frontend "Clear History" button
- Redis service from docker-compose.yml

### Testing Requirements
- **Unit Tests**: session_service functions
- **API Tests**: All endpoints (POST, GET, DELETE)
- **Integration Tests**: Redis connection, fallback behavior
- **Coverage Target**: 90%+
- **Mock Redis**: Use fakeredis or unittest.mock

**Testing Checklist:**
- [ ] Session saves to Redis with correct key format
- [ ] Session saves with 24-hour TTL
- [ ] Session loads correctly
- [ ] Session returns None when expired/not found
- [ ] Session deletes correctly
- [ ] Redis connection errors handled gracefully
- [ ] Fallback to in-memory works
- [ ] All API endpoints return correct status codes
- [ ] Invalid UUIDs rejected

### Performance Considerations
- Redis is in-memory (very fast reads/writes)
- JSON serialization overhead minimal
- Consider compression for large sessions (future optimization)
- Connection pooling handled by redis-py
- Async operations (await) for non-blocking I/O

**Performance Targets:**
- Save operation: < 10ms
- Load operation: < 10ms
- Delete operation: < 5ms

### Accessibility Guidelines
N/A (Backend service, no UI)

### Browser Compatibility
N/A (Backend service, REST API)

### Security Considerations
- **Session ID Validation**: UUID format enforced
- **Data Sanitization**: Pydantic validates request data
- **Redis Security**:
  - Redis not exposed publicly (Docker internal network)
  - No authentication required (local development)
  - Production: Add Redis password (redis-py supports AUTH)
- **TTL Enforcement**: Sessions auto-expire (prevents data accumulation)

**Production Recommendations:**
```python
# Production Redis config
redis_client = redis.Redis(
    host=os.getenv('REDIS_HOST', 'redis'),
    port=int(os.getenv('REDIS_PORT', 6379)),
    password=os.getenv('REDIS_PASSWORD'),  # Add password
    decode_responses=True,
    ssl=True,  # Enable SSL in production
    ssl_cert_reqs='required',
)
```

### Dependencies
[Source: requirements.txt]

```txt
# Redis client
redis==5.0.1

# Already installed
fastapi==0.104.1
pydantic==2.5.0
```

Install with:
```bash
pip install redis
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-01 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
<!-- To be filled by Dev Agent -->

### Debug Log References
<!-- To be filled by Dev Agent -->

### Completion Notes List
<!-- To be filled by Dev Agent -->

### File List
<!-- To be filled by Dev Agent -->

## QA Results
<!-- To be filled by QA Agent -->
