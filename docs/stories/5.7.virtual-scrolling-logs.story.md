# <!-- Powered by BMAD™ Core -->

## Status
Draft

## Story
**As a** user with a long conversation history (1000+ messages),
**I want** the message list to scroll smoothly without performance degradation,
**so that** I can review past messages efficiently

## Acceptance Criteria
1. Install `react-window` library
2. Message list uses virtualized scrolling
3. Only visible messages rendered (viewport + buffer)
4. Handles 1000+ messages with smooth 60fps scrolling
5. Auto-scroll to bottom still works
6. Scroll position preserved when new message arrives (unless at bottom)
7. Message heights calculated dynamically (variable height messages)
8. Search/jump to message functionality works
9. No visual glitches during scroll
10. Maintains existing message animations (fade-in)

## Tasks / Subtasks

- [ ] Task 1: Install react-window library (AC: 1)
  - [ ] Run: `bun add react-window`
  - [ ] Run: `bun add -d @types/react-window`
  - [ ] Verify installation in package.json
  - [ ] Import VariableSizeList in MessageList component

- [ ] Task 2: Replace MessageList with VariableSizeList (AC: 2, 3)
  - [ ] Open `orchestratai_client/src/components/chat/message-list.tsx`
  - [ ] Import VariableSizeList from react-window
  - [ ] Replace existing list rendering with VariableSizeList
  - [ ] Configure height (600px or dynamic based on container)
  - [ ] Configure itemCount (messages.length)
  - [ ] Configure width ("100%")
  - [ ] Add ref for programmatic control

- [ ] Task 3: Implement dynamic height calculation (AC: 7)
  - [ ] Create rowHeights Map to store message heights
  - [ ] Implement getItemSize function
  - [ ] Return stored height or default (100px)
  - [ ] Measure actual message heights with ref
  - [ ] Update rowHeights Map when message resizes
  - [ ] Call listRef.resetAfterIndex() to recalculate

- [ ] Task 4: Create MessageRow component for virtualization (AC: 3, 10)
  - [ ] Create MessageRow component (wraps MessageBubble)
  - [ ] Accept: message, style, setSize, index props
  - [ ] Render MessageBubble inside div with virtualized style
  - [ ] Measure height with useRef and ResizeObserver
  - [ ] Call setSize(index, height) when size known
  - [ ] Maintain fade-in animation from Story 5.1

- [ ] Task 5: Implement auto-scroll to bottom (AC: 5)
  - [ ] Add scrollToItem method to listRef
  - [ ] Detect when new message added (useEffect on messages.length)
  - [ ] Check if user at bottom (isNearBottom helper)
  - [ ] If at bottom: scrollToItem(messages.length - 1)
  - [ ] Use smooth scrolling (behavior: 'smooth')

- [ ] Task 6: Preserve scroll position on new message (AC: 6)
  - [ ] Track current scroll offset (onScroll callback)
  - [ ] Calculate distance from bottom
  - [ ] If user scrolled up: don't auto-scroll
  - [ ] Maintain scroll position when new message arrives
  - [ ] Only auto-scroll if within 100px of bottom

- [ ] Task 7: Add overscan for smooth scrolling (AC: 9)
  - [ ] Configure overscanCount prop (5 items)
  - [ ] Renders 5 items above/below viewport
  - [ ] Prevents blank space during fast scrolling
  - [ ] Test fast scrolling with many messages

- [ ] Task 8: Test with 1000+ messages (AC: 4)
  - [ ] Create test data generator (1000+ mock messages)
  - [ ] Render MessageList with 1000+ messages
  - [ ] Open Chrome DevTools Performance tab
  - [ ] Record scrolling through entire list
  - [ ] Verify 60fps maintained
  - [ ] Verify only ~20 messages rendered at once

- [ ] Task 9: Implement search/jump to message (AC: 8)
  - [ ] Add search input to MessageList (optional for now)
  - [ ] Implement findMessageIndex function
  - [ ] Use scrollToItem(index) to jump to message
  - [ ] Highlight searched message
  - [ ] Test jump maintains scroll position

- [ ] Task 10: Ensure animations still work (AC: 10)
  - [ ] Verify MessageBubble fade-in animation
  - [ ] Verify animation doesn't break virtualization
  - [ ] Use AnimatePresence with mode="popLayout"
  - [ ] Test animations with reduce motion (Story 5.3)

- [ ] Task 11: Write comprehensive tests (AC: All)
  - [ ] Test VariableSizeList renders messages
  - [ ] Test only visible messages in DOM
  - [ ] Test dynamic height calculation
  - [ ] Test auto-scroll to bottom
  - [ ] Test scroll position preservation
  - [ ] Test 1000+ messages performance
  - [ ] Test search/jump functionality
  - [ ] Mock VariableSizeList for unit tests
  - [ ] Achieve 90%+ coverage

## Dev Notes

### Previous Story Context
From Story 2.5 (Message Components):
- MessageBubble component displays individual messages
- MessageList component renders list of messages
- Basic scrolling implemented

From Story 5.1 (Animations):
- Messages have fade-slide animation
- Auto-scroll to bottom implemented
- Smooth scroll behavior

### Architecture References

**react-window Library** [Source: NPM, react-window docs]
- Efficient virtual scrolling library
- Only renders visible items
- Supports variable heights
- Used by Twitter, Facebook, etc.
- 3KB gzipped

**Virtualization Concept**:
- Render only visible items (viewport)
- Reuse DOM elements for off-screen items
- Calculate positions with transforms
- Massive performance improvement for large lists

**Alternative Libraries**:
- `react-virtuoso`: More features, larger bundle
- `@tanstack/react-virtual`: Modern, flexible
- `react-window`: Lightweight, simple (recommended)

### Code Examples

**Installation**:
```bash
bun add react-window
bun add -d @types/react-window
```

**Updated MessageList with Virtualization** (components/chat/message-list.tsx):
```typescript
'use client';

import { useRef, useEffect, useState } from 'react';
import { VariableSizeList as List } from 'react-window';
import { MessageRow } from './message-row';
import type { Message } from '@/lib/types';

interface MessageListProps {
  messages: Message[];
}

export function MessageList({ messages }: MessageListProps) {
  const listRef = useRef<List>(null);
  const rowHeights = useRef<Map<number, number>>(new Map());
  const [listHeight, setListHeight] = useState(600);

  /**
   * Get height for a specific message
   * Returns stored height or default
   */
  const getItemSize = (index: number): number => {
    return rowHeights.current.get(index) || 100; // Default 100px
  };

  /**
   * Update stored height for a message
   * Triggers recalculation of list
   */
  const setRowHeight = (index: number, size: number) => {
    if (rowHeights.current.get(index) !== size) {
      rowHeights.current.set(index, size);
      listRef.current?.resetAfterIndex(index);
    }
  };

  /**
   * Check if user is near bottom of list
   * Used to determine if should auto-scroll
   */
  const isNearBottom = (): boolean => {
    if (!listRef.current) return true;

    // Calculate if within 100px of bottom
    // (react-window doesn't expose scroll position easily)
    // Use a different approach: track scroll offset
    return true; // Simplified for now
  };

  /**
   * Auto-scroll to bottom when new message arrives
   * Only if user is already at bottom
   */
  useEffect(() => {
    if (messages.length === 0) return;

    // Always scroll to bottom on new message
    // TODO: Check if user scrolled up
    listRef.current?.scrollToItem(messages.length - 1, 'end');
  }, [messages.length]);

  /**
   * Adjust list height to fill container
   */
  useEffect(() => {
    const updateHeight = () => {
      const container = document.getElementById('message-list-container');
      if (container) {
        setListHeight(container.clientHeight);
      }
    };

    updateHeight();
    window.addEventListener('resize', updateHeight);
    return () => window.removeEventListener('resize', updateHeight);
  }, []);

  return (
    <div id="message-list-container" className="flex-1">
      <List
        ref={listRef}
        height={listHeight}
        itemCount={messages.length}
        itemSize={getItemSize}
        width="100%"
        overscanCount={5} // Render 5 items above/below viewport
      >
        {({ index, style }) => (
          <MessageRow
            key={messages[index].id}
            message={messages[index]}
            style={style}
            setSize={setRowHeight}
            index={index}
          />
        )}
      </List>
    </div>
  );
}
```

**MessageRow Component** (components/chat/message-row.tsx):
```typescript
'use client';

import { useRef, useEffect } from 'react';
import { motion } from 'framer-motion';
import { MessageBubble } from './message-bubble';
import { fadeSlideUp } from '@/lib/animations';
import { useMotion } from '@/contexts/motion-context';
import type { Message } from '@/lib/types';

interface MessageRowProps {
  message: Message;
  style: React.CSSProperties;
  setSize: (index: number, size: number) => void;
  index: number;
}

/**
 * Wrapper component for MessageBubble in virtualized list
 * Measures height and reports to parent
 */
export function MessageRow({ message, style, setSize, index }: MessageRowProps) {
  const rowRef = useRef<HTMLDivElement>(null);
  const { reducedMotion } = useMotion();

  /**
   * Measure row height and report to parent
   * Uses ResizeObserver for dynamic height changes
   */
  useEffect(() => {
    if (!rowRef.current) return;

    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const height = entry.borderBoxSize?.[0]?.blockSize || entry.contentRect.height;
        setSize(index, height);
      }
    });

    observer.observe(rowRef.current);

    return () => {
      observer.disconnect();
    };
  }, [index, setSize]);

  // Render without animation if reduced motion
  if (reducedMotion) {
    return (
      <div ref={rowRef} style={style}>
        <MessageBubble message={message} />
      </div>
    );
  }

  // Render with animation
  return (
    <motion.div
      ref={rowRef}
      style={style}
      {...fadeSlideUp}
      layout // Animate layout changes
    >
      <MessageBubble message={message} />
    </motion.div>
  );
}
```

**Alternative: Using react-virtuoso** (simpler API):
```typescript
import { Virtuoso } from 'react-virtuoso';

export function MessageList({ messages }: MessageListProps) {
  return (
    <Virtuoso
      data={messages}
      itemContent={(index, message) => (
        <MessageRow message={message} index={index} />
      )}
      followOutput="smooth" // Auto-scroll to bottom
      alignToBottom
    />
  );
}
```

**Performance Testing Script**:
```typescript
// Generate 1000+ mock messages for testing
function generateMockMessages(count: number): Message[] {
  return Array.from({ length: count }, (_, i) => ({
    id: `msg-${i}`,
    role: i % 2 === 0 ? 'user' : 'assistant',
    content: `Message ${i + 1}: ${getRandomContent()}`,
    timestamp: new Date(Date.now() - (count - i) * 60000).toISOString(),
  }));
}

function getRandomContent(): string {
  const lengths = [
    'Short message.',
    'Medium length message with a bit more content to make it realistic.',
    'This is a longer message that spans multiple lines and contains quite a bit of text to simulate real conversation content. It might even include code snippets or detailed explanations.',
  ];
  return lengths[Math.floor(Math.random() * lengths.length)];
}

// Usage in development
const mockMessages = generateMockMessages(1000);
```

**Test Example** (components/chat/__tests__/message-list.test.tsx):
```typescript
import { render, screen } from '@testing-library/react';
import { MessageList } from '../message-list';
import { VariableSizeList } from 'react-window';

// Mock react-window
jest.mock('react-window', () => ({
  VariableSizeList: ({ children, itemCount }: any) => (
    <div data-testid="virtualized-list">
      {Array.from({ length: Math.min(itemCount, 10) }).map((_, i) =>
        children({ index: i, style: {} })
      )}
    </div>
  ),
}));

describe('MessageList virtualization', () => {
  const mockMessages = Array.from({ length: 1000 }, (_, i) => ({
    id: `msg-${i}`,
    role: i % 2 === 0 ? 'user' : 'assistant',
    content: `Message ${i}`,
    timestamp: new Date().toISOString(),
  }));

  it('renders VariableSizeList with correct item count', () => {
    render(<MessageList messages={mockMessages} />);

    const list = screen.getByTestId('virtualized-list');
    expect(list).toBeInTheDocument();
  });

  it('only renders visible messages (not all 1000)', () => {
    const { container } = render(<MessageList messages={mockMessages} />);

    // Should render ~10 messages (mocked), not all 1000
    const renderedMessages = container.querySelectorAll('[data-testid="message-row"]');
    expect(renderedMessages.length).toBeLessThan(20);
  });

  it('auto-scrolls to bottom on new message', () => {
    const scrollToItemMock = jest.fn();
    jest.spyOn(React, 'useRef').mockReturnValue({
      current: { scrollToItem: scrollToItemMock },
    });

    const { rerender } = render(<MessageList messages={mockMessages.slice(0, 10)} />);

    rerender(<MessageList messages={[...mockMessages.slice(0, 10), mockMessages[10]]} />);

    expect(scrollToItemMock).toHaveBeenCalledWith(10, 'end');
  });
});
```

**Dynamic Height Calculation Alternative** (using content-based estimation):
```typescript
/**
 * Estimate message height based on content length
 * Fallback before actual measurement
 */
function estimateMessageHeight(message: Message): number {
  const baseHeight = 60; // Padding + avatar + margins
  const charWidth = 8; // Average character width
  const lineHeight = 24; // Line height in pixels
  const containerWidth = 600; // Message bubble width

  const charsPerLine = Math.floor(containerWidth / charWidth);
  const lines = Math.ceil(message.content.length / charsPerLine);
  const contentHeight = lines * lineHeight;

  return baseHeight + contentHeight;
}
```

### File Structure
[Source: architecture/source-tree.md]

```
orchestratai_client/src/
└── components/
    └── chat/
        ├── message-list.tsx            # UPDATE: Add virtualization
        ├── message-row.tsx             # NEW: Virtualized message wrapper
        ├── message-bubble.tsx          # EXISTING: No changes
        └── __tests__/
            ├── message-list.test.tsx   # UPDATE: Test virtualization
            └── message-row.test.tsx    # NEW: Test row component
```

### Integration Points
- Updates MessageList from Story 2.5
- Maintains animations from Story 5.1
- Respects reduced motion from Story 5.3
- Works with auto-scroll functionality

### Testing Requirements
- **Unit Tests**: MessageList, MessageRow components
- **Performance Tests**: 1000+ messages at 60fps
- **Integration Tests**: Auto-scroll, height calculation
- **Coverage Target**: 90%+
- **Manual Testing**: DevTools Performance profiling

**Testing Checklist:**
- [ ] Only visible messages rendered
- [ ] Dynamic height calculation works
- [ ] Auto-scroll to bottom works
- [ ] Scroll position preserved when not at bottom
- [ ] 1000+ messages maintain 60fps
- [ ] Animations still work
- [ ] Search/jump functionality works
- [ ] No visual glitches during scroll

### Performance Considerations

**Before Virtualization** (1000 messages):
- 1000 DOM elements rendered
- ~100MB memory usage
- Scroll jank (< 30fps)
- Initial render slow (2-3 seconds)

**After Virtualization** (1000 messages):
- ~15-20 DOM elements rendered
- ~10MB memory usage
- Smooth scroll (60fps)
- Initial render fast (< 100ms)

**Performance Metrics:**
- First Render: < 100ms (was 2000ms)
- Scroll FPS: 60fps (was < 30fps)
- Memory: 10MB (was 100MB)
- Time to Interactive: < 200ms (was 3000ms)

**Optimization Tips:**
- Use React.memo for MessageBubble
- Avoid inline functions in render
- Use virtualization library (don't build custom)
- Profile with React DevTools Profiler

### Accessibility Guidelines

**Virtualization and Screen Readers:**
- Screen readers may have issues with virtualized content
- ARIA live regions should announce new messages
- Use `aria-setsize` and `aria-posinset` for list context
- Ensure keyboard navigation works (Tab, Arrow keys)

**Enhancements:**
```typescript
<List
  aria-label="Chat messages"
  aria-live="polite"
  aria-atomic="false"
>
  {({ index, style }) => (
    <div
      role="listitem"
      aria-setsize={messages.length}
      aria-posinset={index + 1}
      style={style}
    >
      <MessageRow message={messages[index]} />
    </div>
  )}
</List>
```

### Browser Compatibility
- **react-window**: Works in all modern browsers
- **ResizeObserver**: 95% support (polyfill available)
- **IntersectionObserver**: 96% support (for lazy loading)
- **Fallback**: Regular scrolling still works without JS

### Known Issues and Solutions

**Issue 1: Initial scroll position**
- Problem: List starts at top instead of bottom
- Solution: Use `initialScrollOffset` or `scrollToItem` on mount

**Issue 2: Height calculation inaccurate**
- Problem: ResizeObserver fires multiple times
- Solution: Debounce height updates

**Issue 3: Animations conflict with virtualization**
- Problem: Framer Motion layout animations break scroll
- Solution: Use simple fade animations, not layout animations

**Issue 4: Search highlighting broken**
- Problem: Highlighted message scrolled out of view
- Solution: Use `scrollToItem` to keep highlighted item visible

### Alternative Solutions

**1. CSS overflow-y: auto (current)**
- Simple
- No virtualization
- Performance issues with 1000+ items

**2. react-window (recommended)**
- Lightweight (3KB)
- Simple API
- Good documentation
- Variable height support

**3. react-virtuoso**
- More features
- Easier API (less boilerplate)
- Larger bundle (12KB)
- Better TypeScript support

**4. @tanstack/react-virtual**
- Modern, headless
- Framework-agnostic
- Most flexible
- Requires more setup

**Recommendation:** Use react-window for this story (lightweight, proven).

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-01 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
<!-- To be filled by Dev Agent -->

### Debug Log References
<!-- To be filled by Dev Agent -->

### Completion Notes List
<!-- To be filled by Dev Agent -->

### File List
<!-- To be filled by Dev Agent -->

## QA Results
<!-- To be filled by QA Agent -->
