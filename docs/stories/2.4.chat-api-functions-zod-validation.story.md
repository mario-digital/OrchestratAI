# Story 2.4: Chat API Functions and Zod Validation

## Status
Draft

## Story
**As a** frontend developer,
**I want** chat-specific API functions with Zod schema validation for requests and responses,
**so that** the application has type-safe chat communication with runtime validation preventing malformed data from reaching the UI.

## Acceptance Criteria
1. Zod schemas created for ChatRequest and ChatResponse matching backend Pydantic models
2. Chat API module created at `lib/api/chat.ts` with `sendMessage()` function
3. All API responses validated against Zod schemas before returning to caller
4. Validation errors thrown as `ValidationError` with detailed error information
5. TypeScript types inferred from Zod schemas (single source of truth)
6. `sendMessage()` function handles session_id generation if not provided
7. UUID validation for session_id using Zod
8. Unit tests verify validation catches malformed backend responses

## Tasks / Subtasks

- [ ] Update Zod schemas in `orchestratai_client/src/lib/schemas.ts` (AC: 1, 7)
  - [ ] Define `ChatRequestSchema` with message (string, min 1, max 2000) and session_id (UUID)
  - [ ] Define `ChatMetricsSchema` with tokensUsed, cost, latency fields
  - [ ] Define `RetrievalLogSchema` with id, type, title, data, timestamp, status
  - [ ] Define `ChatResponseSchema` with message, agent, confidence, logs, metrics
  - [ ] Use `z.string().uuid()` for session_id validation
  - [ ] Use `z.number().min(0).max(1)` for confidence validation
  - [ ] Add `.strict()` to schemas to catch unknown fields

- [ ] Infer TypeScript types from Zod schemas (AC: 5)
  - [ ] Export `ChatRequest = z.infer<typeof ChatRequestSchema>`
  - [ ] Export `ChatResponse = z.infer<typeof ChatResponseSchema>`
  - [ ] Export `ChatMetrics = z.infer<typeof ChatMetricsSchema>`
  - [ ] Export `RetrievalLog = z.infer<typeof RetrievalLogSchema>`
  - [ ] Remove duplicate type definitions (use Zod as single source of truth)

- [ ] Create chat API module in `orchestratai_client/src/lib/api/chat.ts` (AC: 2, 6)
  - [ ] Import apiClient from `lib/api-client`
  - [ ] Import schemas from `lib/schemas`
  - [ ] Import ValidationError from `lib/errors`
  - [ ] Implement `sendMessage(message: string, sessionId?: string)` function
  - [ ] Generate UUID for sessionId if not provided (use `crypto.randomUUID()`)
  - [ ] Validate request data against ChatRequestSchema before sending
  - [ ] Call `apiClient.post('/api/chat', requestData)`
  - [ ] Validate response against ChatResponseSchema (AC: 3, 4)
  - [ ] Throw ValidationError if response doesn't match schema

- [ ] Implement response validation with detailed errors (AC: 4)
  - [ ] Use `ChatResponseSchema.safeParse(response)` for validation
  - [ ] If validation fails, format Zod errors into readable message
  - [ ] Throw ValidationError with formatted message and original Zod errors
  - [ ] Include path to invalid field in error message

- [ ] Create utility function for safe validation (AC: 3, 4)
  - [ ] Create `validateResponse<T>(schema: ZodSchema, data: unknown)` helper
  - [ ] Return typed data if validation succeeds
  - [ ] Throw ValidationError with details if validation fails
  - [ ] Reuse this helper in sendMessage()

- [ ] Write unit tests for chat API functions (AC: 8)
  - [ ] Mock apiClient.post with valid response, verify returns typed data
  - [ ] Mock apiClient.post with missing field, verify throws ValidationError
  - [ ] Mock apiClient.post with wrong type, verify throws ValidationError
  - [ ] Test confidence out of range (1.5) throws ValidationError
  - [ ] Test invalid UUID throws ValidationError
  - [ ] Test message too long (>2000 chars) throws ValidationError
  - [ ] Test sessionId auto-generation when not provided
  - [ ] Verify ValidationError includes field path and error message

- [ ] Add JSDoc comments for API functions (AC: 2)
  - [ ] Document sendMessage() parameters and return type
  - [ ] Document possible errors (APIError, ValidationError, NetworkError)
  - [ ] Add example usage in JSDoc

## Dev Notes

### Previous Story Context
- Story 2.1 created Pydantic models: ChatRequest, ChatResponse
- Story 2.2 created /api/chat endpoint returning ChatResponse
- Story 2.3 created apiClient with error handling and retry logic
- Epic 1 created basic Zod schemas in `lib/schemas.ts` and enums in `lib/enums.ts`

### Data Models
[Source: docs/architecture/4-data-models.md]

**ChatRequest:**
- message: string, 1-2000 characters
- session_id: UUID format string

**ChatResponse:**
- message: string (AI response)
- agent: AgentId enum (orchestrator | billing | technical | policy)
- confidence: number, 0.0 to 1.0
- logs: RetrievalLog[] array
- metrics: ChatMetrics object

**ChatMetrics:**
- tokensUsed: integer
- cost: number (float, USD)
- latency: integer (milliseconds)

**RetrievalLog:**
- id: string (UUID)
- type: LogType enum
- title: string
- data: Record<string, any>
- timestamp: string (ISO 8601)
- status: LogStatus enum

### Zod Schema Patterns
[Source: docs/architecture/3-tech-stack.md]

Runtime validation with Zod ensures type safety at runtime, not just compile time.

**Schema Definition Pattern:**
```typescript
// lib/schemas.ts
import { z } from 'zod';
import { AgentId, MessageRole, LogType, LogStatus } from './enums';

export const ChatRequestSchema = z.object({
  message: z.string().min(1).max(2000),
  session_id: z.string().uuid(),
}).strict();

export const ChatMetricsSchema = z.object({
  tokensUsed: z.number().int().nonnegative(),
  cost: z.number().nonnegative(),
  latency: z.number().int().nonnegative(),
}).strict();

export const RetrievalLogSchema = z.object({
  id: z.string().uuid(),
  type: z.nativeEnum(LogType),
  title: z.string(),
  data: z.record(z.unknown()),
  timestamp: z.string().datetime(),
  status: z.nativeEnum(LogStatus),
}).strict();

export const ChatResponseSchema = z.object({
  message: z.string(),
  agent: z.nativeEnum(AgentId),
  confidence: z.number().min(0).max(1),
  logs: z.array(RetrievalLogSchema),
  metrics: ChatMetricsSchema,
}).strict();

// Type inference
export type ChatRequest = z.infer<typeof ChatRequestSchema>;
export type ChatResponse = z.infer<typeof ChatResponseSchema>;
export type ChatMetrics = z.infer<typeof ChatMetricsSchema>;
export type RetrievalLog = z.infer<typeof RetrievalLogSchema>;
```

### Chat API Implementation Pattern
[Source: docs/architecture/9-frontend-architecture.md#91-component-organization]

```typescript
// lib/api/chat.ts
import { apiClient } from '../api-client';
import { ChatRequestSchema, ChatResponseSchema } from '../schemas';
import type { ChatResponse } from '../schemas';
import { ValidationError } from '../errors';

/**
 * Send a chat message and receive agent response
 * @param message User message text (1-2000 characters)
 * @param sessionId Optional session UUID (auto-generated if not provided)
 * @returns Validated ChatResponse from backend
 * @throws {ValidationError} If request or response fails schema validation
 * @throws {APIError} If backend returns error status
 * @throws {NetworkError} If network request fails
 */
export async function sendMessage(
  message: string,
  sessionId?: string
): Promise<ChatResponse> {
  // Generate session ID if not provided
  const session_id = sessionId || crypto.randomUUID();

  // Validate request
  const requestData = ChatRequestSchema.parse({ message, session_id });

  // Call backend
  const response = await apiClient.post<unknown>('/api/chat', requestData);

  // Validate response
  const result = ChatResponseSchema.safeParse(response);
  if (!result.success) {
    throw new ValidationError(
      'Invalid response from backend',
      result.error
    );
  }

  return result.data;
}
```

### Validation Error Formatting
```typescript
// Helper for formatting Zod errors
function formatZodError(error: ZodError): string {
  return error.issues
    .map(issue => `${issue.path.join('.')}: ${issue.message}`)
    .join('; ');
}
```

### File Locations
[Source: docs/architecture/9-frontend-architecture.md#91-component-organization]

**Create/modify these files:**
```
orchestratai_client/src/lib/
├── schemas.ts            # MODIFY: Add chat schemas
└── api/
    └── chat.ts           # NEW: Chat API functions
```

**Test files:**
```
orchestratai_client/src/lib/api/
└── __tests__/
    └── chat.test.ts
```

### Technical Constraints
[Source: docs/architecture/3-tech-stack.md]

- Zod: 3.23+
- TypeScript: 5.6+
- Use `crypto.randomUUID()` (built-in, no library needed)

### Coding Standards
[Source: docs/architecture/16-coding-standards.md]

- **Type Sharing:** Zod schemas are single source of truth, infer types with `z.infer<>`
- **API Calls:** Use service layer (chat.ts), never direct fetch in components
- **Naming:** camelCase for functions (`sendMessage`)

### Testing

[Source: docs/architecture/15-testing-strategy.md#152-test-examples]

**Test Framework:** Vitest
**Test Location:** `orchestratai_client/src/lib/api/__tests__/chat.test.ts`
**Test Type:** Unit tests (70% of test pyramid)

**Test Pattern:**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { sendMessage } from '../chat';
import { apiClient } from '../../api-client';
import { ValidationError } from '../../errors';

vi.mock('../../api-client');

describe('sendMessage', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should send message and return validated response', async () => {
    const mockResponse = {
      message: 'Test response',
      agent: 'orchestrator',
      confidence: 0.95,
      logs: [],
      metrics: { tokensUsed: 100, cost: 0.001, latency: 500 },
    };

    vi.mocked(apiClient.post).mockResolvedValue(mockResponse);

    const result = await sendMessage('Hello', '550e8400-...');
    expect(result).toEqual(mockResponse);
  });

  it('should throw ValidationError for invalid response', async () => {
    const invalidResponse = {
      message: 'Test',
      // Missing required fields
    };

    vi.mocked(apiClient.post).mockResolvedValue(invalidResponse);

    await expect(sendMessage('Hello')).rejects.toThrow(ValidationError);
  });

  it('should generate UUID if sessionId not provided', async () => {
    vi.mocked(apiClient.post).mockResolvedValue({
      message: 'Test',
      agent: 'orchestrator',
      confidence: 0.9,
      logs: [],
      metrics: { tokensUsed: 100, cost: 0.001, latency: 500 },
    });

    await sendMessage('Hello');

    const callArgs = vi.mocked(apiClient.post).mock.calls[0][1] as any;
    expect(callArgs.session_id).toMatch(
      /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
    );
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
<!-- Populated by dev agent -->

### Debug Log References
<!-- Populated by dev agent -->

### Completion Notes List
<!-- Populated by dev agent -->

### File List
<!-- Populated by dev agent -->

## QA Results
<!-- Populated by QA agent -->
