# Story 2.4: Chat API Functions and Zod Validation

## Status
Done

## Story
**As a** frontend developer,
**I want** chat-specific API functions with Zod schema validation for requests and responses,
**so that** the application has type-safe chat communication with runtime validation preventing malformed data from reaching the UI.

## Acceptance Criteria
1. Zod schemas created for ChatRequest and ChatResponse matching backend Pydantic models
2. Chat API module created at `lib/api/chat.ts` with `sendMessage()` function
3. All API responses validated against Zod schemas before returning to caller
4. Validation errors thrown as `ValidationError` with detailed error information
5. TypeScript types inferred from Zod schemas (single source of truth)
6. `sendMessage()` function handles session_id generation if not provided
7. UUID validation for session_id using Zod
8. Unit tests verify validation catches malformed backend responses

## Tasks / Subtasks

- [x] Update Zod schemas in `orchestratai_client/src/lib/schemas.ts` (AC: 1, 7)
  - [x] Define `ChatRequestSchema` with message (string, min 1, max 2000) and session_id (UUID)
  - [x] Define `ChatMetricsSchema` with tokensUsed, cost, latency fields
  - [x] Define `RetrievalLogSchema` with id, type, title, data, timestamp, status
  - [x] Define `ChatResponseSchema` with message, agent, confidence, logs, metrics
  - [x] Use `z.string().uuid()` for session_id validation
  - [x] Use `z.number().min(0).max(1)` for confidence validation
  - [x] Add `.strict()` to schemas to catch unknown fields

- [x] Infer TypeScript types from Zod schemas (AC: 5)
  - [x] Export `ChatRequest = z.infer<typeof ChatRequestSchema>`
  - [x] Export `ChatResponse = z.infer<typeof ChatResponseSchema>`
  - [x] Export `ChatMetrics = z.infer<typeof ChatMetricsSchema>`
  - [x] Export `RetrievalLog = z.infer<typeof RetrievalLogSchema>`
  - [x] Remove duplicate type definitions (use Zod as single source of truth)

- [x] Create chat API module in `orchestratai_client/src/lib/api/chat.ts` (AC: 2, 6)
  - [x] Import apiClient from `lib/api-client`
  - [x] Import schemas from `lib/schemas`
  - [x] Import ValidationError from `lib/errors`
  - [x] Implement `sendMessage(message: string, sessionId?: string)` function
  - [x] Generate UUID for sessionId if not provided (use `crypto.randomUUID()`)
  - [x] Validate request data against ChatRequestSchema before sending
  - [x] Call `apiClient.post('/api/chat', requestData)`
  - [x] Validate response against ChatResponseSchema (AC: 3, 4)
  - [x] Throw ValidationError if response doesn't match schema

- [x] Implement response validation with detailed errors (AC: 4)
  - [x] Use `ChatResponseSchema.safeParse(response)` for validation
  - [x] If validation fails, format Zod errors into readable message
  - [x] Throw ValidationError with formatted message and original Zod errors
  - [x] Include path to invalid field in error message

- [x] Create utility function for safe validation (AC: 3, 4)
  - [x] Create `validateResponse<T>(schema: ZodSchema, data: unknown)` helper
  - [x] Return typed data if validation succeeds
  - [x] Throw ValidationError with details if validation fails
  - [x] Reuse this helper in sendMessage()

- [x] Write unit tests for chat API functions (AC: 8)
  - [x] Mock apiClient.post with valid response, verify returns typed data
  - [x] Mock apiClient.post with missing field, verify throws ValidationError
  - [x] Mock apiClient.post with wrong type, verify throws ValidationError
  - [x] Test confidence out of range (1.5) throws ValidationError
  - [x] Test invalid UUID throws ValidationError
  - [x] Test message too long (>2000 chars) throws ValidationError
  - [x] Test sessionId auto-generation when not provided
  - [x] Verify ValidationError includes field path and error message

- [x] Add JSDoc comments for API functions (AC: 2)
  - [x] Document sendMessage() parameters and return type
  - [x] Document possible errors (APIError, ValidationError, NetworkError)
  - [x] Add example usage in JSDoc

## Dev Notes

### Previous Story Context
- Story 2.1 created Pydantic models: ChatRequest, ChatResponse
- Story 2.2 created /api/chat endpoint returning ChatResponse
- Story 2.3 created apiClient with error handling and retry logic
- Epic 1 created basic Zod schemas in `lib/schemas.ts` and enums in `lib/enums.ts`

### Data Models
[Source: docs/architecture/4-data-models.md]

**ChatRequest:**
- message: string, 1-2000 characters
- session_id: UUID format string

**ChatResponse:**
- message: string (AI response)
- agent: AgentId enum (orchestrator | billing | technical | policy)
- confidence: number, 0.0 to 1.0
- logs: RetrievalLog[] array
- metrics: ChatMetrics object

**ChatMetrics:**
- tokensUsed: integer
- cost: number (float, USD)
- latency: integer (milliseconds)

**RetrievalLog:**
- id: string (UUID)
- type: LogType enum
- title: string
- data: Record<string, any>
- timestamp: string (ISO 8601)
- status: LogStatus enum

### Zod Schema Patterns
[Source: docs/architecture/3-tech-stack.md]

Runtime validation with Zod ensures type safety at runtime, not just compile time.

**Schema Definition Pattern:**
```typescript
// lib/schemas.ts
import { z } from 'zod';
import { AgentId, MessageRole, LogType, LogStatus } from './enums';

export const ChatRequestSchema = z.object({
  message: z.string().min(1).max(2000),
  session_id: z.string().uuid(),
}).strict();

export const ChatMetricsSchema = z.object({
  tokensUsed: z.number().int().nonnegative(),
  cost: z.number().nonnegative(),
  latency: z.number().int().nonnegative(),
}).strict();

export const RetrievalLogSchema = z.object({
  id: z.string().uuid(),
  type: z.nativeEnum(LogType),
  title: z.string(),
  data: z.record(z.unknown()),
  timestamp: z.string().datetime(),
  status: z.nativeEnum(LogStatus),
}).strict();

export const ChatResponseSchema = z.object({
  message: z.string(),
  agent: z.nativeEnum(AgentId),
  confidence: z.number().min(0).max(1),
  logs: z.array(RetrievalLogSchema),
  metrics: ChatMetricsSchema,
}).strict();

// Type inference
export type ChatRequest = z.infer<typeof ChatRequestSchema>;
export type ChatResponse = z.infer<typeof ChatResponseSchema>;
export type ChatMetrics = z.infer<typeof ChatMetricsSchema>;
export type RetrievalLog = z.infer<typeof RetrievalLogSchema>;
```

### Chat API Implementation Pattern
[Source: docs/architecture/9-frontend-architecture.md#91-component-organization]

```typescript
// lib/api/chat.ts
import { apiClient } from '../api-client';
import { ChatRequestSchema, ChatResponseSchema } from '../schemas';
import type { ChatResponse } from '../schemas';
import { ValidationError } from '../errors';

/**
 * Send a chat message and receive agent response
 * @param message User message text (1-2000 characters)
 * @param sessionId Optional session UUID (auto-generated if not provided)
 * @returns Validated ChatResponse from backend
 * @throws {ValidationError} If request or response fails schema validation
 * @throws {APIError} If backend returns error status
 * @throws {NetworkError} If network request fails
 */
export async function sendMessage(
  message: string,
  sessionId?: string
): Promise<ChatResponse> {
  // Generate session ID if not provided
  const session_id = sessionId || crypto.randomUUID();

  // Validate request
  const requestData = ChatRequestSchema.parse({ message, session_id });

  // Call backend
  const response = await apiClient.post<unknown>('/api/chat', requestData);

  // Validate response
  const result = ChatResponseSchema.safeParse(response);
  if (!result.success) {
    throw new ValidationError(
      'Invalid response from backend',
      result.error
    );
  }

  return result.data;
}
```

### Validation Error Formatting
```typescript
// Helper for formatting Zod errors
function formatZodError(error: ZodError): string {
  return error.issues
    .map(issue => `${issue.path.join('.')}: ${issue.message}`)
    .join('; ');
}
```

### File Locations
[Source: docs/architecture/9-frontend-architecture.md#91-component-organization]

**Create/modify these files:**
```
orchestratai_client/src/lib/
├── schemas.ts            # MODIFY: Add chat schemas
└── api/
    └── chat.ts           # NEW: Chat API functions
```

**Test files:**
```
orchestratai_client/src/lib/api/
└── __tests__/
    └── chat.test.ts
```

### Technical Constraints
[Source: docs/architecture/3-tech-stack.md]

- Zod: 3.23+
- TypeScript: 5.6+
- Use `crypto.randomUUID()` (built-in, no library needed)

### Coding Standards
[Source: docs/architecture/16-coding-standards.md]

- **Type Sharing:** Zod schemas are single source of truth, infer types with `z.infer<>`
- **API Calls:** Use service layer (chat.ts), never direct fetch in components
- **Naming:** camelCase for functions (`sendMessage`)

### Testing

[Source: docs/architecture/15-testing-strategy.md#152-test-examples]

**Test Framework:** Vitest
**Test Location:** `orchestratai_client/src/lib/api/__tests__/chat.test.ts`
**Test Type:** Unit tests (70% of test pyramid)

**Test Pattern:**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { sendMessage } from '../chat';
import { apiClient } from '../../api-client';
import { ValidationError } from '../../errors';

vi.mock('../../api-client');

describe('sendMessage', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should send message and return validated response', async () => {
    const mockResponse = {
      message: 'Test response',
      agent: 'orchestrator',
      confidence: 0.95,
      logs: [],
      metrics: { tokensUsed: 100, cost: 0.001, latency: 500 },
    };

    vi.mocked(apiClient.post).mockResolvedValue(mockResponse);

    const result = await sendMessage('Hello', '550e8400-...');
    expect(result).toEqual(mockResponse);
  });

  it('should throw ValidationError for invalid response', async () => {
    const invalidResponse = {
      message: 'Test',
      // Missing required fields
    };

    vi.mocked(apiClient.post).mockResolvedValue(invalidResponse);

    await expect(sendMessage('Hello')).rejects.toThrow(ValidationError);
  });

  it('should generate UUID if sessionId not provided', async () => {
    vi.mocked(apiClient.post).mockResolvedValue({
      message: 'Test',
      agent: 'orchestrator',
      confidence: 0.9,
      logs: [],
      metrics: { tokensUsed: 100, cost: 0.001, latency: 500 },
    });

    await sendMessage('Hello');

    const callArgs = vi.mocked(apiClient.post).mock.calls[0][1] as any;
    expect(callArgs.session_id).toMatch(
      /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
    );
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Initial story creation | Scrum Master (Bob) |
| 2025-10-26 | 1.1 | Implementation completed - All tasks done, tests passing | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
No debug logs required - implementation completed without issues.

### Completion Notes List
- All Zod schemas were already defined in schemas.ts from Epic 1
- Added type inference exports to schemas.ts for single source of truth
- Created new lib/api/ directory and chat.ts module
- Implemented sendMessage() with auto UUID generation
- Created validateResponse() helper for reusable validation
- All 16 unit tests pass with 100% coverage on chat.ts
- Total test suite: 145 tests passing
- Overall coverage: 89.13% (exceeds 80% requirement)
- ESLint passed with no warnings
- All acceptance criteria met

### File List
**Modified:**
- orchestratai_client/src/lib/schemas.ts - Added type inference exports

**Created:**
- orchestratai_client/src/lib/api/chat.ts - Chat API module with sendMessage() and validateResponse()
- orchestratai_client/src/lib/api/__tests__/chat.test.ts - Comprehensive unit tests (16 tests)

## QA Results

### Review Date: 2025-10-26

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Quality: EXCELLENT**

The implementation demonstrates exceptional code quality with comprehensive validation, excellent test coverage, and professional documentation. All acceptance criteria have been met with thorough implementation that follows best practices.

**Key Strengths:**
- **100% test coverage** on chat.ts module (16 comprehensive tests)
- **Robust validation** using Zod schemas with strict mode preventing unknown fields
- **Excellent error handling** with detailed error messages including field paths
- **Professional JSDoc comments** providing clear API documentation with examples
- **Type safety** achieved through Zod schema inference (single source of truth)
- **Clean architecture** with reusable `validateResponse()` helper function
- **Comprehensive edge case coverage** including boundary testing

### Refactoring Performed

No refactoring was required. The code is production-ready as implemented.

### Requirements Traceability Matrix

**AC 1: Zod schemas created for ChatRequest and ChatResponse matching backend Pydantic models**
- **Given** backend has Pydantic models for ChatRequest and ChatResponse
- **When** frontend defines Zod schemas
- **Then** schemas match backend structure with proper validation rules
- **Tests**: All validation tests in chat.test.ts (lines 77-171)
- **Status**: ✓ COVERED

**AC 2: Chat API module created at `lib/api/chat.ts` with `sendMessage()` function**
- **Given** need for type-safe chat API
- **When** sendMessage() is called
- **Then** request is validated, sent, and response validated
- **Tests**: lines 27-48 (happy path), lines 50-75 (UUID generation)
- **Status**: ✓ COVERED

**AC 3: All API responses validated against Zod schemas before returning to caller**
- **Given** API returns response data
- **When** response validation is performed
- **Then** only valid responses are returned to caller
- **Tests**: lines 91-171 (all validation failure scenarios)
- **Status**: ✓ COVERED

**AC 4: Validation errors thrown as `ValidationError` with detailed error information**
- **Given** invalid request or response data
- **When** validation is performed
- **Then** ValidationError is thrown with field paths and messages
- **Tests**: lines 200-222 (field path verification), lines 240-268 (error formatting)
- **Status**: ✓ COVERED

**AC 5: TypeScript types inferred from Zod schemas (single source of truth)**
- **Given** Zod schemas are defined
- **When** types are needed
- **Then** z.infer<> provides types from schemas
- **Implementation**: schemas.ts lines 209-249
- **Status**: ✓ COVERED (verified through type system, no runtime test needed)

**AC 6: `sendMessage()` function handles session_id generation if not provided**
- **Given** user calls sendMessage() without session_id
- **When** function executes
- **Then** crypto.randomUUID() generates valid UUID v4
- **Tests**: lines 50-75 (UUID generation and format validation)
- **Status**: ✓ COVERED

**AC 7: UUID validation for session_id using Zod**
- **Given** invalid UUID provided
- **When** validation is performed
- **Then** Zod throws error for invalid UUID format
- **Tests**: lines 87-89 (invalid UUID rejection)
- **Status**: ✓ COVERED

**AC 8: Unit tests verify validation catches malformed backend responses**
- **Given** backend returns malformed response
- **When** validation is performed
- **Then** ValidationError is thrown with specific details
- **Tests**: lines 91-171 (missing fields, wrong types, out-of-range, invalid enums, unknown fields)
- **Status**: ✓ COVERED

**Coverage Summary:** 8/8 ACs fully tested with Given-When-Then validation scenarios

### Compliance Check

- **Coding Standards**: ✓ PASS
  - camelCase naming for functions (sendMessage, validateResponse)
  - Service layer pattern correctly used (no direct fetch)
  - Type sharing via Zod schemas as single source of truth
  - Proper JSDoc documentation with examples

- **Project Structure**: ✓ PASS
  - Files correctly placed in lib/api/ directory
  - Test files in proper __tests__/ subdirectory
  - Clear module separation (schemas, api, errors)

- **Testing Strategy**: ✓ PASS
  - Unit tests correctly placed (70% pyramid target)
  - Comprehensive test coverage (100% on chat.ts)
  - Tests follow Vitest patterns with describe/it/expect
  - Proper mocking of apiClient dependency
  - Edge cases and error paths thoroughly tested

- **All ACs Met**: ✓ PASS
  - All 8 acceptance criteria fully implemented
  - Comprehensive validation as specified
  - All technical requirements satisfied

### Non-Functional Requirements Assessment

**Security: PASS**
- ✓ UUID validation prevents injection attacks
- ✓ Strict Zod schemas reject unknown fields (.strict() mode)
- ✓ Message length limits (1-2000 chars) prevent oversized payloads
- ✓ No sensitive data logged or exposed
- ✓ ValidationError properly sanitizes error details

**Performance: PASS**
- ✓ Efficient Zod validation (minimal overhead)
- ✓ Single schema parse per request/response
- ✓ No unnecessary object cloning or transformations
- ✓ Reusable validateResponse() helper prevents code duplication

**Reliability: PASS**
- ✓ Comprehensive error handling for all failure scenarios
- ✓ Type safety through Zod prevents runtime type errors
- ✓ Clear error messages aid debugging
- ✓ Validation catches malformed data before UI processing

**Maintainability: EXCELLENT**
- ✓ Excellent JSDoc comments with usage examples
- ✓ Clear function responsibilities (single responsibility principle)
- ✓ Reusable helper functions (validateResponse, formatZodError)
- ✓ 100% test coverage ensures safe refactoring
- ✓ Type inference from schemas eliminates type drift

### Test Architecture Assessment

**Test Coverage: EXCELLENT (100%)**
- 16 comprehensive tests covering all code paths
- All acceptance criteria have corresponding test scenarios
- Edge cases thoroughly validated (boundaries, invalid inputs)
- Error path coverage complete

**Test Design Quality: EXCELLENT**
- Clear test organization with descriptive names
- Proper setup/teardown with beforeEach
- Good use of mocking (apiClient properly isolated)
- Tests are independent and repeatable
- Assertion clarity with specific expectations

**Test Levels: APPROPRIATE**
- Unit tests at correct level (testing module in isolation)
- No inappropriate integration tests at unit level
- Proper mocking strategy for external dependencies

### Testability Evaluation

**Controllability: EXCELLENT**
- All inputs easily controlled through function parameters
- Mock setup straightforward and reliable
- Test data easily constructed

**Observability: EXCELLENT**
- Clear return values and error types
- ValidationError includes detailed field information
- Easy to verify correct behavior through assertions

**Debuggability: EXCELLENT**
- Clear error messages with field paths
- Stack traces properly maintained via Error.captureStackTrace
- Test failures provide actionable information

### Technical Debt Assessment

**Identified Debt: NONE**

This implementation introduces zero technical debt:
- ✓ No shortcuts or workarounds
- ✓ Comprehensive test coverage from start
- ✓ No TODOs or FIXMEs in code
- ✓ Follows all architectural patterns
- ✓ Documentation complete

### Security Review

**No security concerns identified.**

The implementation includes appropriate security measures:
- Input validation with length limits
- UUID format validation
- Strict schema validation preventing data injection
- No exposure of sensitive information in errors
- Proper error handling without information leakage

### Performance Considerations

**No performance concerns identified.**

The implementation is efficient:
- Minimal validation overhead (single parse per operation)
- No unnecessary computations or allocations
- Built-in crypto.randomUUID() is performant
- No synchronous blocking operations

### Files Modified During Review

**None** - No modifications were necessary. The implementation is production-ready as delivered.

### Gate Status

**Gate: PASS** → docs/qa/gates/2.4-chat-api-functions-zod-validation.yml

This is an exemplary implementation that exceeds quality expectations. All acceptance criteria met, 100% test coverage, zero technical debt, and professional documentation.

### Recommended Status

**✓ Ready for Done**

This story meets all quality gates and is ready for production deployment. The implementation demonstrates best practices and serves as an excellent reference for future API module development.
