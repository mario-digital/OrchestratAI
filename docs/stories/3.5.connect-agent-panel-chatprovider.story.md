# Story 3.5: Connect Agent Panel to ChatProvider State

## Status
Draft

## Story
**As a** user,
**I want** the agent panel to update in real-time when I send messages,
**so that** I can see which agent is processing my request and track metrics accumulation.

## Acceptance Criteria
1. ChatProvider state extended with `agents` field (Record<AgentId, AgentState>)
2. ChatProvider exposes `updateAgentStatus` method
3. ChatProvider exposes `incrementAgentMetrics` method
4. Agent state updates when chat API response received
5. Orchestrator transitions IDLE → ROUTING → IDLE (with UI delays)
6. Selected agent transitions IDLE → ACTIVE → COMPLETE
7. Metrics accumulate correctly across multiple messages
8. AgentPanel reads from ChatProvider context
9. AgentCard components re-render when agent state changes
10. React.memo optimization prevents unnecessary re-renders

## Tasks / Subtasks

- [ ] Extend ChatState interface (AC: 1)
  - [ ] Open `orchestratai_client/src/components/providers/chat-provider.tsx`
  - [ ] Add AgentState interface:
    ```typescript
    interface AgentState {
      status: AgentStatus;
      model: string;
      strategy: RetrievalStrategy | null;
      metrics: {
        tokens: number;
        cost: number;
        latency: number;
      };
      cacheStatus: "hit" | "miss" | "none";
    }
    ```
  - [ ] Add `agents: Record<AgentId, AgentState>` to ChatState
  - [ ] Initialize with all 4 agents in IDLE state with zero metrics

- [ ] Add agent state actions to reducer (AC: 2, 3)
  - [ ] Add new action types to ChatAction union:
    ```typescript
    | { type: "UPDATE_AGENT_STATUS"; payload: { agent: AgentId; status: AgentStatus } }
    | { type: "INCREMENT_AGENT_METRICS"; payload: { agent: AgentId; metrics: Partial<AgentState["metrics"]>; cacheStatus?: string } }
    | { type: "SET_ALL_AGENT_STATUS"; payload: Record<AgentId, AgentStatus> }
    ```
  - [ ] Implement reducer cases for new actions
  - [ ] UPDATE_AGENT_STATUS: Update single agent status
  - [ ] INCREMENT_AGENT_METRICS: Add to existing metrics
  - [ ] SET_ALL_AGENT_STATUS: Batch update all agent statuses

- [ ] Add agent update methods to ChatProvider (AC: 2, 3)
  - [ ] Add `updateAgentStatus` function to ChatProvider
  - [ ] Add `incrementAgentMetrics` function to ChatProvider
  - [ ] Expose methods in ChatContextValue interface
  - [ ] Export methods from context

- [ ] Update sendMessage to trigger agent updates (AC: 4, 5, 6, 7)
  - [ ] In sendMessage function, after API call starts:
    - Set orchestrator to ROUTING status
    - Wait 500ms (allow UI to show transition)
    - Set orchestrator back to IDLE
    - Set target agent (from API response) to ACTIVE
  - [ ] After API response received:
    - Parse agent_status from response
    - Call SET_ALL_AGENT_STATUS with response data
    - Parse metrics from response
    - Call incrementAgentMetrics for the selected agent
    - Parse cache_status and update agent

- [ ] Create custom hook useChatAgents (AC: 8)
  - [ ] Create file `orchestratai_client/src/hooks/use-chat-agents.ts`
  - [ ] Export useChatAgents hook:
    ```typescript
    export function useChatAgents() {
      const context = useContext(ChatContext);
      if (!context) throw new Error("useChatAgents must be used within ChatProvider");
      return {
        agents: context.agents,
        updateAgentStatus: context.updateAgentStatus,
        incrementAgentMetrics: context.incrementAgentMetrics,
      };
    }
    ```

- [ ] Update AgentPanel to use ChatProvider (AC: 8)
  - [ ] Import useChatAgents hook in agent-panel.tsx
  - [ ] Remove agents prop from AgentPanelProps
  - [ ] Call useChatAgents() to get agents state
  - [ ] Map agents object to array for rendering
  - [ ] Ensure agents render in correct order

- [ ] Add React.memo to AgentCard (AC: 9, 10)
  - [ ] Wrap AgentCard with React.memo export
  - [ ] Add custom comparison function to check:
    - status changed
    - metrics changed
    - cacheStatus changed
  - [ ] Prevents re-render if unrelated agent updates

- [ ] Handle agent status transitions with delays (AC: 5, 6)
  - [ ] In sendMessage, use setTimeout for orchestrator transition:
    ```typescript
    updateAgentStatus(AgentId.ORCHESTRATOR, AgentStatus.ROUTING);
    setTimeout(() => {
      updateAgentStatus(AgentId.ORCHESTRATOR, AgentStatus.IDLE);
    }, 500);
    ```
  - [ ] Set target agent to ACTIVE immediately after orchestrator
  - [ ] Agent status from API response sets final COMPLETE state

- [ ] Initialize agent state with defaults (AC: 1)
  - [ ] Create INITIAL_AGENTS constant in chat-provider.tsx:
    ```typescript
    const INITIAL_AGENTS: Record<AgentId, AgentState> = {
      [AgentId.ORCHESTRATOR]: {
        status: AgentStatus.IDLE,
        model: "OpenAI GPT-4o",
        strategy: null,
        metrics: { tokens: 0, cost: 0, latency: 0 },
        cacheStatus: "none",
      },
      [AgentId.BILLING]: { /* same structure */ },
      [AgentId.TECHNICAL]: { /* same structure */ },
      [AgentId.POLICY]: { /* same structure */ },
    };
    ```
  - [ ] Use INITIAL_AGENTS in initial state

- [ ] Write unit tests for agent reducer actions (AC: 4, 5, 6)
  - [ ] Create test file `orchestratai_client/tests/unit/components/providers/chat-provider-agents.test.ts`
  - [ ] Test UPDATE_AGENT_STATUS updates single agent
  - [ ] Test INCREMENT_AGENT_METRICS adds to existing metrics
  - [ ] Test SET_ALL_AGENT_STATUS batch updates
  - [ ] Test metrics accumulation across multiple increments

- [ ] Write integration test for agent panel updates (AC: 8, 9)
  - [ ] Create test file `orchestratai_client/tests/integration/agent-panel-updates.test.tsx`
  - [ ] Render AgentPanel within ChatProvider
  - [ ] Simulate message send
  - [ ] Assert orchestrator status changes to ROUTING then IDLE
  - [ ] Assert selected agent status changes to ACTIVE then COMPLETE
  - [ ] Assert metrics update correctly

## Dev Notes

### Source Tree Info
[Source: docs/architecture/source-tree.md]
- ChatProvider: `orchestratai_client/src/components/providers/chat-provider.tsx`
- Custom Hook: `orchestratai_client/src/hooks/use-chat-agents.ts`
- Tests: `orchestratai_client/tests/unit/components/providers/`
- Tests: `orchestratai_client/tests/integration/`

### ChatProvider State Extension
[Source: docs/stories/epic-3-agent-log-panels.md#State Management Updates]

**New State Fields**:
```typescript
interface ChatState {
  // ... existing fields from Epic 2
  messages: Message[];
  isProcessing: boolean;
  sessionId: string | null;
  error: Error | null;
  typingAgent: AgentId | null;
  failedMessage: string | null;

  // NEW: Agent state (Epic 3)
  agents: Record<AgentId, AgentState>;
}
```

**Initial State**:
```typescript
const initialState: ChatState = {
  // ... existing Epic 2 state
  agents: INITIAL_AGENTS,  // NEW
};
```

### Agent Status Transition Logic
[Source: docs/stories/epic-3-agent-log-panels.md#How It Integrates]

**Message Flow**:
```
1. User sends message
2. Frontend: Orchestrator → ROUTING
3. [500ms delay for UX]
4. Frontend: Orchestrator → IDLE
5. Frontend: Selected agent → ACTIVE
6. Backend responds with agent_status
7. Frontend: Apply agent_status from response (selected agent → COMPLETE)
```

**Implementation**:
```typescript
const sendMessage = async (message: string) => {
  dispatch({ type: "SET_PROCESSING", payload: true });

  // Orchestrator routing animation
  dispatch({ type: "UPDATE_AGENT_STATUS", payload: { agent: AgentId.ORCHESTRATOR, status: AgentStatus.ROUTING } });

  setTimeout(() => {
    dispatch({ type: "UPDATE_AGENT_STATUS", payload: { agent: AgentId.ORCHESTRATOR, status: AgentStatus.IDLE } });
  }, 500);

  const result = await sendMessageAPI(message, sessionId);

  if (result.success) {
    // Update agent statuses from API response
    dispatch({ type: "SET_ALL_AGENT_STATUS", payload: result.data.agent_status });

    // Increment metrics for the selected agent
    dispatch({
      type: "INCREMENT_AGENT_METRICS",
      payload: {
        agent: result.data.agent,
        metrics: result.data.metrics,
        cacheStatus: result.data.metrics.cache_status,
      },
    });
  }

  dispatch({ type: "SET_PROCESSING", payload: false });
};
```

### React.memo Optimization
[Source: docs/stories/epic-3-agent-log-panels.md#Performance Optimization]

**Problem**: When one agent updates, all 4 AgentCards re-render

**Solution**: Wrap AgentCard with React.memo and custom comparison

```typescript
export const AgentCard = React.memo(
  function AgentCard(props: AgentCardProps) {
    // ... component implementation
  },
  (prevProps, nextProps) => {
    // Only re-render if this specific agent's data changed
    return (
      prevProps.status === nextProps.status &&
      prevProps.metrics.tokens === nextProps.metrics.tokens &&
      prevProps.metrics.cost === nextProps.metrics.cost &&
      prevProps.metrics.latency === nextProps.metrics.latency &&
      prevProps.cacheStatus === nextProps.cacheStatus
    );
  }
);
```

### Metrics Accumulation
[Source: docs/stories/epic-3-agent-log-panels.md#Scenario 3]

**Requirement**: Metrics should accumulate across messages
- Message 1: Billing agent uses 450 tokens → Display "450"
- Message 2: Billing agent uses 300 tokens → Display "750" (450 + 300)
- Cost and latency should also accumulate

**Reducer Logic**:
```typescript
case "INCREMENT_AGENT_METRICS":
  return {
    ...state,
    agents: {
      ...state.agents,
      [action.payload.agent]: {
        ...state.agents[action.payload.agent],
        metrics: {
          tokens: state.agents[action.payload.agent].metrics.tokens + (action.payload.metrics.tokens || 0),
          cost: state.agents[action.payload.agent].metrics.cost + (action.payload.metrics.cost || 0),
          latency: state.agents[action.payload.agent].metrics.latency + (action.payload.metrics.latency || 0),
        },
        cacheStatus: action.payload.cacheStatus || state.agents[action.payload.agent].cacheStatus,
      },
    },
  };
```

### Testing Strategy
[Source: docs/architecture/15-testing-strategy.md]

**Unit Tests** (chat-provider-agents.test.ts):
```typescript
describe('ChatProvider agent state', () => {
  it('initializes all agents with IDLE status', () => {
    // Test INITIAL_AGENTS constant
  });

  it('updates single agent status', () => {
    // Test UPDATE_AGENT_STATUS action
  });

  it('accumulates metrics correctly', () => {
    // Dispatch INCREMENT_AGENT_METRICS twice
    // Assert metrics sum correctly
  });
});
```

**Integration Tests** (agent-panel-updates.test.tsx):
```typescript
describe('AgentPanel with ChatProvider', () => {
  it('updates agent status when message sent', async () => {
    render(
      <ChatProvider>
        <AgentPanel />
      </ChatProvider>
    );

    const { sendMessage } = useChatAgents();
    await sendMessage("Test message");

    // Assert orchestrator went ROUTING then IDLE
    // Assert selected agent went ACTIVE then COMPLETE
  });
});
```

### Integration with Previous Stories
- **Story 3.3**: AgentCard component must be updated to accept context data
- **Story 3.4**: AgentMetrics already in AgentCard, now receives real data
- **Story 3.1-3.2**: Backend provides agent_status and metrics in response

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Initial story creation for Epic 3 | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
<!-- Dev agent fills this in during implementation -->

### Debug Log References
<!-- Dev agent references debug logs here -->

### Completion Notes
<!-- Dev agent notes during implementation -->

### File List
<!-- Dev agent lists all modified files -->

## QA Results
<!-- QA agent fills this after validation -->
