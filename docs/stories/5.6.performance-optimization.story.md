# <!-- Powered by BMAD™ Core -->

## Status
Draft

## Story
**As a** user,
**I want** my previous conversation to load automatically when I return,
**so that** I can continue where I left off without losing context

## Acceptance Criteria
1. On app load, check localStorage for session_id
2. If session_id exists, call GET `/api/session/{id}`
3. If session found, restore messages, agents, logs to state
4. If session not found (expired), start fresh
5. Show "Resume Session" toast notification when session loaded
6. Session_id persisted to localStorage on first message
7. "Clear History" button deletes both local and Redis session
8. Loading state shown while fetching session
9. Error handled gracefully if session fetch fails
10. Session saves automatically after each message sent

## Tasks / Subtasks

- [ ] Task 1: Create session API client functions (AC: 2, 7, 10)
  - [ ] Create `orchestratai_client/src/lib/api/session.ts`
  - [ ] Import apiClient from existing API setup
  - [ ] Define SessionData interface (TypeScript type)
  - [ ] Implement `loadSession(sessionId: string)` function
  - [ ] Implement `saveSession(sessionId: string, data: SessionData)` function
  - [ ] Implement `deleteSession(sessionId: string)` function
  - [ ] Add error handling for network failures
  - [ ] Export all functions

- [ ] Task 2: Add session loading to ChatProvider (AC: 1, 2, 3, 4, 8, 9)
  - [ ] Open `orchestratai_client/src/contexts/chat-context.tsx`
  - [ ] Import session API functions
  - [ ] Add useEffect hook for initial session load (on mount)
  - [ ] Check localStorage for 'sessionId'
  - [ ] If found, call loadSession() API
  - [ ] If successful, dispatch RESTORE_SESSION action
  - [ ] If failed (404), remove sessionId from localStorage
  - [ ] If network error, log and start fresh
  - [ ] Add loading state while fetching

- [ ] Task 3: Add RESTORE_SESSION action to chat reducer (AC: 3)
  - [ ] Open ChatProvider reducer function
  - [ ] Add RESTORE_SESSION case to reducer
  - [ ] Restore messages from session data
  - [ ] Restore agent state from session data
  - [ ] Restore logs from session data
  - [ ] Set loading state to false
  - [ ] Ensure no duplicate messages

- [ ] Task 4: Persist session_id to localStorage (AC: 6)
  - [ ] Update sendMessage function in ChatProvider
  - [ ] On first message, generate new UUID for session_id
  - [ ] Store session_id in localStorage: `localStorage.setItem('sessionId', id)`
  - [ ] Store session_id in state for future saves
  - [ ] Only generate once (check if already exists)

- [ ] Task 5: Auto-save session after each message (AC: 10)
  - [ ] Update sendMessage function
  - [ ] After receiving assistant response
  - [ ] Collect current state: messages, agents, logs
  - [ ] Call saveSession(sessionId, data)
  - [ ] Handle save errors gracefully (log, don't block UI)
  - [ ] Don't show save notifications (background operation)

- [ ] Task 6: Add toast notification for session restore (AC: 5)
  - [ ] Install toast library if not already: `sonner` or `react-hot-toast`
  - [ ] Import toast in ChatProvider
  - [ ] After successful session restore
  - [ ] Show toast: "Session restored" with success styling
  - [ ] Auto-dismiss after 3 seconds

- [ ] Task 7: Update clearMessages to delete session (AC: 7)
  - [ ] Open clearMessages function in ChatProvider
  - [ ] Call deleteSession(sessionId) API
  - [ ] Remove sessionId from localStorage
  - [ ] Clear all state (messages, agents, logs)
  - [ ] Show toast: "History cleared"

- [ ] Task 8: Add loading state UI (AC: 8)
  - [ ] Add `isLoadingSession` to ChatProvider state
  - [ ] Show loading spinner in ChatInterface while loading
  - [ ] Display "Restoring session..." message
  - [ ] Prevent user from sending messages during load
  - [ ] Hide loading after restore complete or failed

- [ ] Task 9: Handle session restore errors (AC: 9)
  - [ ] If session load returns 404 (expired)
    - Remove sessionId from localStorage
    - Start fresh session
    - Show toast: "Previous session expired"
  - [ ] If network error
    - Log error
    - Start fresh session
    - Show toast: "Failed to restore session"
  - [ ] If malformed session data
    - Remove sessionId from localStorage
    - Start fresh session
    - Show toast: "Session data corrupted"

- [ ] Task 10: Add session expiration warning (AC: 4)
  - [ ] Optional: Store session creation timestamp in localStorage
  - [ ] Optional: Show warning if session > 23 hours old
  - [ ] Optional: "Your session will expire in 1 hour"
  - [ ] For now: Just handle expired gracefully (Task 9)

- [ ] Task 11: Write comprehensive tests (AC: All)
  - [ ] Test session API functions (mock fetch)
  - [ ] Test loadSession on mount with existing sessionId
  - [ ] Test loadSession with no sessionId (fresh start)
  - [ ] Test loadSession with expired session (404)
  - [ ] Test loadSession with network error
  - [ ] Test auto-save after sending message
  - [ ] Test clearMessages deletes session
  - [ ] Test toast notifications display correctly
  - [ ] Test loading state shows/hides correctly
  - [ ] Achieve 90%+ coverage

## Dev Notes

### Previous Story Context
From Story 2.7 (Chat State Management):
- ChatProvider manages messages, agents, logs
- sendMessage function sends messages to backend
- clearMessages function clears all state

From Story 5.5 (Redis Session Backend):
- Backend endpoints: POST, GET, DELETE /api/session
- Session data structure defined
- 24-hour TTL on sessions

### Architecture References

**Chat Context** [Source: 9-frontend-architecture.md]
- ChatProvider wraps entire app
- Manages global chat state
- Provides sendMessage, clearMessages functions
- React Context + useReducer pattern

**API Client** [Source: 9-frontend-architecture.md]
- Centralized API client with error handling
- Base URL configuration
- Authentication headers (if needed)

**localStorage** [Source: Web APIs]
- Browser storage API (5-10MB limit)
- Persists across page refreshes
- Synchronous API
- Available in all modern browsers

### Code Examples

**Session API Functions** (lib/api/session.ts):
```typescript
/**
 * Session management API client
 * Interfaces with backend session endpoints
 */

import { apiClient } from './client';

export interface SessionData {
  session_id: string;
  messages: Message[];
  agents: Record<string, AgentState>;
  logs: LogEntry[];
  last_updated: string;
}

export interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

export interface AgentState {
  status: string;
  model: string;
  metrics: {
    tokens: number;
    cost: number;
    latency: number;
  };
}

export interface LogEntry {
  timestamp: string;
  agent: string;
  event: string;
  details: any;
}

/**
 * Load session data from backend
 * @param sessionId - UUID of session to load
 * @returns Session data or null if not found
 */
export async function loadSession(sessionId: string): Promise<SessionData | null> {
  try {
    const response = await apiClient.get(`/api/session/${sessionId}`);
    return response.data.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      // Session expired or not found
      return null;
    }
    throw error;
  }
}

/**
 * Save session data to backend
 * @param sessionId - UUID of session
 * @param data - Session data to save
 */
export async function saveSession(
  sessionId: string,
  data: Omit<SessionData, 'session_id'>
): Promise<void> {
  await apiClient.post('/api/session', {
    session_id: sessionId,
    data: {
      ...data,
      last_updated: new Date().toISOString(),
    },
  });
}

/**
 * Delete session data from backend
 * @param sessionId - UUID of session to delete
 */
export async function deleteSession(sessionId: string): Promise<void> {
  await apiClient.delete(`/api/session/${sessionId}`);
}
```

**Updated ChatProvider with Session Loading** (contexts/chat-context.tsx):
```typescript
'use client';

import { createContext, useContext, useEffect, useReducer, useState } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { toast } from 'sonner';
import { loadSession, saveSession, deleteSession } from '@/lib/api/session';
import type { Message, AgentState, LogEntry } from '@/lib/types';

interface ChatState {
  messages: Message[];
  agents: Record<string, AgentState>;
  logs: LogEntry[];
  sessionId: string | null;
  isLoadingSession: boolean;
}

type ChatAction =
  | { type: 'ADD_MESSAGE'; payload: Message }
  | { type: 'CLEAR_MESSAGES' }
  | { type: 'UPDATE_AGENT_STATE'; payload: { agent: string; state: AgentState } }
  | { type: 'ADD_LOG'; payload: LogEntry }
  | { type: 'RESTORE_SESSION'; payload: SessionData }
  | { type: 'SET_SESSION_ID'; payload: string }
  | { type: 'SET_LOADING_SESSION'; payload: boolean };

const initialState: ChatState = {
  messages: [],
  agents: {},
  logs: [],
  sessionId: null,
  isLoadingSession: false,
};

function chatReducer(state: ChatState, action: ChatAction): ChatState {
  switch (action.type) {
    case 'ADD_MESSAGE':
      return { ...state, messages: [...state.messages, action.payload] };

    case 'CLEAR_MESSAGES':
      return { ...state, messages: [], agents: {}, logs: [], sessionId: null };

    case 'UPDATE_AGENT_STATE':
      return {
        ...state,
        agents: {
          ...state.agents,
          [action.payload.agent]: action.payload.state,
        },
      };

    case 'ADD_LOG':
      return { ...state, logs: [...state.logs, action.payload] };

    case 'RESTORE_SESSION':
      return {
        ...state,
        messages: action.payload.messages,
        agents: action.payload.agents,
        logs: action.payload.logs,
        sessionId: action.payload.session_id,
        isLoadingSession: false,
      };

    case 'SET_SESSION_ID':
      return { ...state, sessionId: action.payload };

    case 'SET_LOADING_SESSION':
      return { ...state, isLoadingSession: action.payload };

    default:
      return state;
  }
}

const ChatContext = createContext<{
  state: ChatState;
  sendMessage: (content: string) => Promise<void>;
  clearMessages: () => void;
} | null>(null);

export function ChatProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(chatReducer, initialState);

  // Load session on mount
  useEffect(() => {
    const loadExistingSession = async () => {
      const sessionId = localStorage.getItem('sessionId');

      if (!sessionId) {
        // No existing session, start fresh
        return;
      }

      try {
        dispatch({ type: 'SET_LOADING_SESSION', payload: true });

        const sessionData = await loadSession(sessionId);

        if (sessionData) {
          // Session found, restore it
          dispatch({ type: 'RESTORE_SESSION', payload: sessionData });
          toast.success('Session restored');
        } else {
          // Session expired (404)
          localStorage.removeItem('sessionId');
          toast.info('Previous session expired');
          dispatch({ type: 'SET_LOADING_SESSION', payload: false });
        }
      } catch (error) {
        // Network error or other failure
        console.error('Failed to load session:', error);
        localStorage.removeItem('sessionId');
        toast.error('Failed to restore session');
        dispatch({ type: 'SET_LOADING_SESSION', payload: false });
      }
    };

    loadExistingSession();
  }, []);

  const sendMessage = async (content: string) => {
    // Ensure we have a session ID
    let sessionId = state.sessionId;

    if (!sessionId) {
      // First message, create new session
      sessionId = uuidv4();
      dispatch({ type: 'SET_SESSION_ID', payload: sessionId });
      localStorage.setItem('sessionId', sessionId);
    }

    // Add user message
    const userMessage: Message = {
      id: uuidv4(),
      role: 'user',
      content,
      timestamp: new Date().toISOString(),
    };
    dispatch({ type: 'ADD_MESSAGE', payload: userMessage });

    // Send to backend (existing logic)
    try {
      const response = await chatAPI.sendMessage(content);

      // Add assistant response
      const assistantMessage: Message = {
        id: uuidv4(),
        role: 'assistant',
        content: response.content,
        timestamp: new Date().toISOString(),
      };
      dispatch({ type: 'ADD_MESSAGE', payload: assistantMessage });

      // Auto-save session after response
      try {
        await saveSession(sessionId, {
          messages: [...state.messages, userMessage, assistantMessage],
          agents: state.agents,
          logs: state.logs,
        });
      } catch (saveError) {
        // Log but don't block UI
        console.error('Failed to save session:', saveError);
      }
    } catch (error) {
      console.error('Failed to send message:', error);
      toast.error('Failed to send message');
    }
  };

  const clearMessages = async () => {
    if (state.sessionId) {
      try {
        await deleteSession(state.sessionId);
        localStorage.removeItem('sessionId');
      } catch (error) {
        console.error('Failed to delete session:', error);
      }
    }

    dispatch({ type: 'CLEAR_MESSAGES' });
    toast.success('History cleared');
  };

  return (
    <ChatContext.Provider value={{ state, sendMessage, clearMessages }}>
      {children}
    </ChatContext.Provider>
  );
}

export function useChat() {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChat must be used within ChatProvider');
  }
  return context;
}
```

**Loading State UI** (components/chat/chat-interface.tsx):
```typescript
'use client';

import { useChat } from '@/contexts/chat-context';
import { MessageList } from './message-list';
import { MessageInput } from './message-input';
import { Loader2 } from 'lucide-react';

export function ChatInterface() {
  const { state, sendMessage } = useChat();

  if (state.isLoadingSession) {
    return (
      <div className="flex h-full items-center justify-center">
        <div className="text-center">
          <Loader2 className="mx-auto h-8 w-8 animate-spin text-primary" />
          <p className="mt-2 text-sm text-muted-foreground">
            Restoring session...
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-full flex-col">
      <MessageList messages={state.messages} />
      <MessageInput onSendMessage={sendMessage} disabled={state.isLoadingSession} />
    </div>
  );
}
```

**Toast Notifications Setup**:
```bash
# Install Sonner (lightweight toast library)
bun add sonner
```

```typescript
// app/layout.tsx
import { Toaster } from 'sonner';

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        {children}
        <Toaster position="top-right" richColors />
      </body>
    </html>
  );
}
```

**Test Example** (contexts/__tests__/chat-context.test.tsx):
```typescript
import { renderHook, act, waitFor } from '@testing-library/react';
import { ChatProvider, useChat } from '../chat-context';
import * as sessionAPI from '@/lib/api/session';
import { toast } from 'sonner';

jest.mock('@/lib/api/session');
jest.mock('sonner');

describe('ChatProvider session loading', () => {
  beforeEach(() => {
    localStorage.clear();
    jest.clearAllMocks();
  });

  it('loads session on mount if sessionId exists', async () => {
    const mockSessionData = {
      session_id: 'test-session-id',
      messages: [{ id: '1', role: 'user', content: 'Hello', timestamp: '2025-11-01T10:00:00Z' }],
      agents: {},
      logs: [],
    };

    localStorage.setItem('sessionId', 'test-session-id');
    (sessionAPI.loadSession as jest.Mock).mockResolvedValue(mockSessionData);

    const { result } = renderHook(() => useChat(), {
      wrapper: ChatProvider,
    });

    await waitFor(() => {
      expect(result.current.state.messages).toHaveLength(1);
    });

    expect(sessionAPI.loadSession).toHaveBeenCalledWith('test-session-id');
    expect(toast.success).toHaveBeenCalledWith('Session restored');
  });

  it('starts fresh if no sessionId in localStorage', async () => {
    const { result } = renderHook(() => useChat(), {
      wrapper: ChatProvider,
    });

    expect(result.current.state.messages).toHaveLength(0);
    expect(sessionAPI.loadSession).not.toHaveBeenCalled();
  });

  it('handles expired session (404)', async () => {
    localStorage.setItem('sessionId', 'expired-session-id');
    (sessionAPI.loadSession as jest.Mock).mockResolvedValue(null);

    const { result } = renderHook(() => useChat(), {
      wrapper: ChatProvider,
    });

    await waitFor(() => {
      expect(toast.info).toHaveBeenCalledWith('Previous session expired');
    });

    expect(localStorage.getItem('sessionId')).toBeNull();
  });

  it('auto-saves session after sending message', async () => {
    (sessionAPI.saveSession as jest.Mock).mockResolvedValue(undefined);

    const { result } = renderHook(() => useChat(), {
      wrapper: ChatProvider,
    });

    await act(async () => {
      await result.current.sendMessage('Hello');
    });

    await waitFor(() => {
      expect(sessionAPI.saveSession).toHaveBeenCalled();
    });
  });

  it('deletes session when clearing messages', async () => {
    localStorage.setItem('sessionId', 'test-session-id');
    (sessionAPI.deleteSession as jest.Mock).mockResolvedValue(undefined);

    const { result } = renderHook(() => useChat(), {
      wrapper: ChatProvider,
    });

    await act(async () => {
      result.current.clearMessages();
    });

    expect(sessionAPI.deleteSession).toHaveBeenCalledWith('test-session-id');
    expect(localStorage.getItem('sessionId')).toBeNull();
  });
});
```

### File Structure
[Source: architecture/source-tree.md]

```
orchestratai_client/src/
├── lib/
│   └── api/
│       ├── client.ts                   # EXISTING: Base API client
│       ├── session.ts                  # NEW: Session API functions
│       └── __tests__/
│           └── session.test.ts         # NEW: Session API tests
├── contexts/
│   ├── chat-context.tsx                # UPDATE: Add session loading/saving
│   └── __tests__/
│       └── chat-context.test.tsx       # UPDATE: Add session tests
├── components/
│   └── chat/
│       └── chat-interface.tsx          # UPDATE: Add loading state UI
└── app/
    └── layout.tsx                      # UPDATE: Add Toaster component
```

### Integration Points
- Uses backend endpoints from Story 5.5
- Integrates with ChatProvider from Story 2.7
- Updates sendMessage and clearMessages functions
- Uses localStorage for session ID persistence
- Toast notifications for user feedback

### Testing Requirements
- **Unit Tests**: Session API functions
- **Context Tests**: Session loading, saving, deleting
- **Integration Tests**: Full session lifecycle
- **Coverage Target**: 90%+
- **Mock API calls**: Use jest.mock

**Testing Checklist:**
- [ ] Session loads on mount with existing ID
- [ ] Session doesn't load if no ID in localStorage
- [ ] Session handles 404 (expired)
- [ ] Session handles network errors
- [ ] Session ID created on first message
- [ ] Session auto-saves after each message
- [ ] Session deletes on clear
- [ ] Toast notifications appear correctly
- [ ] Loading state shows/hides correctly

### Performance Considerations
- localStorage is synchronous (fast, but blocks)
- Session load happens on mount (async, doesn't block render)
- Auto-save is fire-and-forget (doesn't block UI)
- Consider debouncing auto-save if messages sent rapidly
- Session data should be < 5MB (localStorage limit)

**Optimization Ideas:**
- Debounce auto-save (save max once per 5 seconds)
- Compress session data (gzip) if large
- Only save diffs (incremental updates)

### Accessibility Guidelines
- Loading state has accessible "Restoring session..." text
- Screen reader announces toast notifications
- Keyboard navigation not affected by loading state
- Focus management preserved during restore

### Browser Compatibility
- **localStorage**: 100% support (all modern browsers)
- **uuid library**: Works everywhere
- **Async/await**: ES2017+ (all modern browsers)
- **Toast library (Sonner)**: Modern browsers only

### Error Handling Strategy

**Session Load Errors:**
1. **404 Not Found** (expired):
   - Remove sessionId from localStorage
   - Start fresh
   - Toast: "Previous session expired"

2. **Network Error**:
   - Log error
   - Start fresh
   - Toast: "Failed to restore session"

3. **Malformed Data**:
   - Remove sessionId
   - Start fresh
   - Toast: "Session data corrupted"

**Session Save Errors:**
- Log error (don't show toast)
- Don't block UI
- User can continue chatting
- Next auto-save will retry

**Session Delete Errors:**
- Log error
- Remove from localStorage anyway
- Clear local state
- Toast: "History cleared" (even if delete failed)

### Dependencies
```json
{
  "dependencies": {
    "uuid": "^9.0.1",
    "sonner": "^1.3.1"
  },
  "devDependencies": {
    "@types/uuid": "^9.0.7"
  }
}
```

Install with:
```bash
bun add uuid sonner
bun add -d @types/uuid
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-01 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
<!-- To be filled by Dev Agent -->

### Debug Log References
<!-- To be filled by Dev Agent -->

### Completion Notes List
<!-- To be filled by Dev Agent -->

### File List
<!-- To be filled by Dev Agent -->

## QA Results
<!-- To be filled by QA Agent -->
